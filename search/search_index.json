{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pareto","text":"<p>Spatial Containers, Pareto Fronts, and Pareto Archives</p> <p></p> <p></p> <p>While most problems need to simultaneously organize objects according to many criteria, associative containers can only index objects in a single dimension. This library provides a number of containers with optimal asymptotic complexity to represent multi-dimensional associative containers. </p> <p>These containers are useful in many applications such as games, maps, nearest neighbor search, range search, compression algorithms, statistics, mechanics, graphics libraries, database queries, finance, multi-criteria decision making, optimization, machine learning, hyper-parameter tuning, approximation algorithms, networks, routing algorithms, robust optimization, design, and systems control.</p> <p></p> <p> </p> <p></p> <p> </p> <p></p>"},{"location":"references/","title":"References","text":"<p>These are some references we used for this work:</p> <ul> <li> <p>J. Blank and K. Deb, pymoo:   Multi-objective Optimization in Python, IEEE Access, 2020, 1-1</p> </li> <li> <p>ECJ then and now, Luke, Sean, Proceedings of the Genetic and Evolutionary Computation Conference Companion,   1223--1230, 2017</p> </li> <li> <p>PlatEMO: A MATLAB platform for evolutionary multi-objective optimization [educational forum], Tian, Ye and Cheng,   Ran and Zhang, Xingyi and Jin, Yaochu, IEEE Computational Intelligence Magazine, 12, 4, 73--87, 2017, IEEE</p> </li> <li> <p>PISA---a platform and programming language independent interface for search algorithms, Bleuler, Stefan and Laumanns,   Marco and Thiele, Lothar and Zitzler, Eckart, International Conference on Evolutionary Multi-Criterion Optimization,   494--508, 2003, Springer</p> </li> <li> <p>ParadisEO-MOEO: A framework for evolutionary multi-objective optimization, Liefooghe, Arnaud and Basseur, Matthieu and   Jourdan, Laetitia and Talbi, El-Ghazali, International Conference on Evolutionary Multi-Criterion Optimization,   386--400, 2007, Springer</p> </li> <li> <p>Opt4J: a modular framework for meta-heuristic optimization, Lukasiewycz, Martin and Glass=tex, Michael and Reimann,   Felix and Teich, Jurgen, Proceedings of the 13th annual conference on Genetic and evolutionary computation,   1723--1730, 2011</p> </li> <li> <p>MOEA framework: a free and open source java framework for multiobjective optimization, Hadka, David, 2012, Version</p> </li> <li> <p>Redesigning the jMetal multi-objective optimization framework, Nebro, Antonio J and Durillo, Juan J and Vergne,   Matthieu, Proceedings of the companion publication of the 2015 annual conference on genetic and evolutionary   computation, 1093--1100, 2015</p> </li> <li> <p>jMetal: A Java framework for multi-objective optimization, Durillo, Juan J and Nebro, Antonio J, Advances in   Engineering Software, 42, 10, 760--771, 2011, Elsevier</p> </li> <li> <p>An extensible JCLEC-based solution for the implementation of multi-objective evolutionary algorithms, Ramirez, Aurora   and Romero, Jose Raul and Ventura, Sebastian, Proceedings of the Companion Publication of the 2015 Annual Conference   on Genetic and Evolutionary Computation, 1085--1092, 2015</p> </li> <li> <p>EvA: a tool for optimization with evolutionary algorithms, Wakunda, Jurgen and Zell, Andreas, EUROMICRO 97.   Proceedings of the 23rd EUROMICRO Conference: New Frontiers of Information Technology (Cat. No. 97TB100167), 644--651,   1997, IEEE</p> </li> <li> <p>Interpersonal Comparisons of the Good: Epistemic not Impossible, Coakley, Mathew, Utilitas, 28, 3, 288--313, 2016,   Cambridge University Press</p> </li> <li> <p>Multiobjective genetic algorithms, Fonseca, Carlos M and Fleming, Peter J, IEE colloquium on genetic algorithms for   control systems engineering, 6--1, 1993, IET</p> </li> <li> <p>The efficiency theorems and market failure, Hammond, P, Elements of General Equilibrium Analysis, 211--260, 1998,   Oxford:   Blackwell</p> </li> <li> <p>MCDM---if not a roman numeral, then what?, Zionts, Stanley, Interfaces, 9, 4, 94--101, 1979, INFORMS</p> </li> <li> <p>Performance indicators in multiobjective optimization, Audet, Charles and Bigeon, J and Cartier, D and Le Digabel,   Sebastien and Salomon, Ludovic, Optimization Online, 2018</p> </li> <li> <p>Output-sensitive peeling of convex and maximal layers, Nielsen, Franck, Information processing letters, 59, 5,   255--259, 1996, Elsevier</p> </li> <li> <p>On finding the maxima of a set of vectors, Kung, Hsiang-Tsung and Luccio, Fabrizio and Preparata, Franco P, Journal of   the ACM (JACM), 22, 4, 469--476, 1975, ACM New York, NY, USA</p> </li> <li> <p>Algorithms and analyses for maximal vector computation, Godfrey, Parke and Shipley, Ryan and Gryz, Jarek, The VLDB   Journal, 16, 1, 5--28, 2007, Springer</p> </li> <li> <p>Adaptive weighted sum method for multiobjective optimization: a new method for Pareto front generation, Kim, Il Yong   and De Weck, OL, Structural and multidisciplinary optimization, 31, 2, 105--116, 2006, Springer</p> </li> <li> <p>On a bicriterion formation of the problems of integrated system identification and system optimization, YV, YV HAIMES   and Lasdon, Leon S and Da Wismer, DA, IEEE Transactions on Systems, Man and Cybernetics, 3, 296--297, 1971, Institute   of Electrical and Electronics Engineers Inc.</p> </li> <li> <p>Effective implementation of the \\(\\varepsilon\\)-constraint method in multi-objective mathematical programming problems,   Mavrotas, George, Applied mathematics and computation, 213, 2, 455--465, 2009, Elsevier</p> </li> <li> <p>Deductive sort and climbing sort: New methods for non-dominated sorting, McClymont, Kent and Keedwell, Ed,   Evolutionary computation, 20, 1, 1--26, 2012, MIT Press</p> </li> <li> <p>An efficient non-dominated sorting method for evolutionary algorithms, Fang, Hongbing and Wang, Qian and Tu, Yi-Cheng   and Horstemeyer, Mark F, Evolutionary computation, 16, 3, 355--384, 2008, MIT Press</p> </li> <li> <p>Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms, Jensen, Mikkel T, IEEE   Transactions on Evolutionary Computation, 7, 5, 503--515, 2003, IEEE</p> </li> <li> <p>An efficient approach to nondominated sorting for evolutionary multiobjective optimization, Zhang, Xingyi and Tian, Ye   and Cheng, Ran and Jin, Yaochu, IEEE Transactions on Evolutionary Computation, 19, 2, 201--213, 2014, IEEE</p> </li> <li> <p>Comparison of data structures for storing Pareto-sets in MOEAs, Mostaghim, Sanaz and Teich, Jurgen and Tyagi, Ambrish,   Proceedings of the 2002 Congress on Evolutionary Computation. CEC'02 (Cat. No. 02TH8600), 1, 843--848, 2002, IEEE</p> </li> <li> <p>A fast incremental BSP tree archive for non-dominated points, Glasmachers, Tobias, International Conference on   Evolutionary Multi-Criterion Optimization, 252--266, 2017, Springer</p> </li> <li> <p>Data structures in multi-objective evolutionary algorithms, Altwaijry, Najwa and Menai, Mohamed El Bachir, Journal of   Computer Science and Technology, 27, 6, 1197--1210, 2012, Springer</p> </li> <li> <p>An efficient approach to unbounded bi-objective archives- introducing the mak_tree algorithm, Berry, Adam and Vamplew,   Peter, Proceedings of the 8th annual conference on Genetic and evolutionary computation, 619--626, 2006</p> </li> <li> <p>ND-tree-based update: a fast algorithm for the dynamic nondominance problem, Jaszkiewicz, Andrzej and Lust, Thibaut,   IEEE Transactions on Evolutionary Computation, 22, 5, 778--791, 2018, IEEE @articlealberto2004representation,   Representation and management of MOEA populations based on graphs, Alberto, Isolina and Mateo, Pedro M, European   Journal of Operational Research, 159, 1, 52--65, 2004, Elsevier A dominance tree and its application in evolutionary   multi-objective optimization, Shi, Chuan and Yan, Zhenyu and Lu, Kevin and Shi, Zhongzhi and Wang, Bai, Information   Sciences, 179, 20, 3540--3560, 2009, Elsevier</p> </li> <li> <p>Using unconstrained elite archives for multiobjective optimization, Fieldsend, Jonathan T and Everson, Richard M and   Singh, Sameer, IEEE Transactions on Evolutionary Computation, 7, 3, 305--323, 2003, IEEE</p> </li> <li> <p>A fast multi-objective evolutionary algorithm based on a tree structure, Shi, Chuan and Yan, Zhenyu and Shi, Zhongzhi   and Zhang, Lei, Applied Soft Computing, 10, 2, 468--480, 2010, Elsevier</p> </li> <li> <p>InterQuad: An interactive quad tree based procedure for solving the discrete alternative multiple criteria problem,   Sun, Minghe and Steuer, Ralph T, European Journal of Operational Research, 89, 3, 462--472, 1996, Elsevier</p> </li> <li> <p>Quad trees, a datastructures for discrete vector optimization problems, Habenicht, Walter, Essays and Surveys on   Multiple Criteria Decision Making, 136--145, 1983, Springer</p> </li> <li> <p>Full elite sets for multi-objective optimisation, Everson, Richard M and Fieldsend, Jonathan T and Singh, Sameer,   Adaptive Computing in Design and Manufacture V, 343--354, 2002, Springer</p> </li> <li> <p>Priority search trees, McCreight, Edward M, SIAM Journal on Computing, 14, 2, 257--276, 1985, SIAM</p> </li> <li> <p>Data structures for range searching, Bentley, Jon Louis and Friedman, Jerome H, ACM Computing Surveys (CSUR), 11, 4,   397--409, 1979, ACM New York, NY, USA</p> </li> <li> <p>Multidimensional binary search trees used for associative searching, Bentley, Jon Louis, Communications of the ACM,   18, 9, 509--517, 1975, ACM New York, NY, USA</p> </li> <li> <p>The art of Unix programming, Raymond, Eric S, 2003, Addison-Wesley Professional</p> </li> <li> <p>Quad-trees and linear lists for identifying nondominated criterion vectors, Sun, Minghe and Steuer, Ralph T, INFORMS   Journal on Computing, 8, 4, 367--375, 1996, INFORMS</p> </li> <li> <p>A new data structure for the nondominance problem in multi-objective optimization, Schutze, Oliver, International   Conference on Evolutionary Multi-Criterion Optimization, 509--518, 2003, Springer</p> </li> <li> <p>The legacy of modern portfolio theory, Fabozzi, Frank J and Gupta, Francis and Markowitz, Harry M, The Journal of   Investing, 11, 3, 7--22, 2002, Institutional Investor Journals Umbrella</p> </li> <li> <p>Tensorflow: A system for large-scale machine learning, Abadi, Marti=texn and Barham, Paul and Chen, Jianmin and Chen,   Zhifeng and Davis, Andy and Dean, Jeffrey and Devin, Matthieu and Ghemawat, Sanjay and Irving, Geoffrey and Isard,   Michael and others, 12th \\(\\$USENIX\\)$ Symposium on Operating Systems Design and Implementation (\\(\\$OSDI\\)$ 16),   265--283, 2016</p> </li> <li> <p>Quad trees a data structure for retrieval on composite keys, Finkel, Raphael A. and Bentley, Jon Louis, Acta   informatica, 4, 1, 1--9, 1974, Springer</p> </li> <li> <p>Multidimensional binary search trees used for associative searching, Bentley, Jon Louis, Communications of the ACM,   18, 9, 509--517, 1975, ACM New York, NY, USA</p> </li> <li> <p>Geometric modeling using octree encoding, Meagher, Donald, Computer graphics and image processing, 19, 2, 129--147,   1982, Elsevier</p> </li> <li> <p>The R*-tree: an efficient and robust access method for points and rectangles, Beckmann, Norbert and Kriegel,   Hans-Peter and Schneider, Ralf and Seeger, Bernhard, Proceedings of the 1990 ACM SIGMOD international conference on   Management of data, 322--331, 1990</p> </li> <li> <p>R-trees: A dynamic index structure for spatial searching, Guttman, Antonin, Proceedings of the 1984 ACM SIGMOD   international conference on Management of data, 47--57, 1984</p> </li> <li> <p>The X-tree: An index structure for high-dimensional data, Berchtold, Stefan and Keim, Daniel A and Kriegel,   Hans-Peter, Very Large Data-Bases, 28--39, 1996</p> </li> <li> <p>Quadboost: A scalable concurrent quadtree, Zhou, Keren and Tan, Guangming and Zhou, Wei, IEEE Transactions on Parallel   and Distributed Systems, 29, 3, 673--686, 2017, IEEE</p> </li> <li> <p>Distance browsing in spatial databases, Hjaltason, Gi=texsli R and Samet, Hanan, ACM Transactions on Database   Systems (TODS), 24, 2, 265--318, 1999, ACM New York, NY, USA</p> </li> <li> <p>An improved dimension-sweep algorithm for the hypervolume indicator, Fonseca, Carlos M and Paquete, Lui=texs and   Lopez-Ibanez, Manuel, 2006 IEEE international conference on evolutionary computation, 1157--1163, 2006, IEEE</p> </li> <li> <p>Speeding up many-objective optimization by Monte Carlo approximations, Bringmann, Karl and Friedrich, Tobias and Igel,   Christian and Voss=tex, Thomas, Artificial Intelligence, 204, 22--29, 2013, Elsevier</p> </li> <li> <p>On the complexity of computing the hypervolume indicator, Beume, Nicola and Fonseca, Carlos M and Lopez-Ibanez, Manuel   and Paquete, Lui=texs and Vahrenhold, Jan, IEEE Transactions on Evolutionary Computation, 13, 5, 1075--1082, 2009,   IEEE</p> </li> <li> <p>Aggregation trees for visualization and dimension reduction in many-objective optimization, de Freitas, Alan RR and   Fleming, Peter J and Guimaraes, Frederico G, Information Sciences, 298, 288--314, 2015, Elsevier</p> </li> <li> <p>Difficulties in specifying reference points to calculate the inverted generational distance for many-objective   optimization problems, Ishibuchi, Hisao and Masuda, Hiroyuki and Tanigaki, Yuki and Nojima, Yusuke, 2014 IEEE   Symposium on Computational Intelligence in Multi-Criteria Decision-Making (MCDM), 170--177, 2014, IEEE </p> </li> </ul>"},{"location":"archive-container/allocators/","title":"Allocators","text":"Method AllocatorAwareContainer <code>allocator_type get_allocator() const noexcept;</code> <p>Return value</p> <p>The associated allocator.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>This function returns the allocator of the underlying container.</p> <p>Because an archive handles a set of containers, some which are exponentially smaller than other, the archive does not delegate the task of handling the allocators to its underlying containers. Instead, the archive keeps a copy of the allocator and constructs each new underlying container with this allocator. If the archive contains a PMR allocator, the new container also shares the same memory resources. This is intended to make memory allocations faster for the last fronts, which are usually allocated and deallocated often with few elements. </p> <p>Info</p> <p>See the section on spatial map allocators for more information.</p> <p>Example</p> C++ <pre><code>#include &lt;pareto/archive.h&gt;\n// ...\npareto::archive&lt;double, 3, unsigned&gt; ar;\n// Get a copy of the container allocator\nauto alloc = ar.get_allocator();\n</code></pre>"},{"location":"archive-container/archive-concept/","title":"Archive Concept","text":"<p>It's often useful to cache elements even if they are not in the Pareto front. For instance, in dynamic applications, we might need a replacement for an element in the front that's not longer available, or only few elements might make it to the front and we might need more options. In these cases, you can use Pareto archives to keep track of the elements which are second-best, third-best, ....</p> <p>A Pareto archive \\(A\\) is then a list of Pareto fronts \\([P^1, P^2, \\dots, P^{|A|}]\\) ordered by their ranks. In other words, the archive front \\(P^{i+1}\\) is the Pareto front we would have if we removed \\(P^i \\cup P^{i-1} \\cup \\dots \\cup P^1\\) from \\(F\\).</p> <p>Pareto archive</p> <p>A two-dimensional Pareto archive</p> <p></p> <p>An archive works as if it were a multidimensional stack</p> <p>Formal Definition: Pareto archive</p> <p>A Pareto archive \\(A\\) is a list of Pareto fronts \\([P^1, P^2, \\dots, P^{|A|}]\\) ordered by their ranks. Given the set of feasible solutions \\(F\\), a front \\(P^i\\) is and archive \\(A\\) are defined as</p> \\[ \\begin{equation} \\label{eq:archive_front} \\begin{split} A &amp; = \\{P^1, P^2, \\dots\\} \\\\ P^i &amp; = \\begin{cases} P &amp;\\mbox{if } i = 1 \\\\ \\{ x \\in F \\;|\\; \\tilde \\exists y \\in (F \\setminus P^{i-1} \\setminus P^{i-2} \\setminus \\dots \\setminus P^1) \\; y \\prec x \\} &amp;\\mbox{if } i \\neq 1 \\end{cases} \\end{split} \\end{equation} \\] <p>The archive interface has all the functions a usual front has: insertion, removal, and querying. Searching operations identify the proper front for the elements. Functions for indicators and dominance relationships use the first fronts as reference.</p> <p>When we insert a new element into the archive, and this element dominates other solutions in the archive, the container moves the dominated elements to higher fronts efficiently instead of erasing them.</p>"},{"location":"archive-container/capacity-and-reference-points/","title":"Capacity and Reference Points","text":"Method MultimapContainer Check size <code>[[nodiscard]] bool empty() const noexcept;</code> <code>[[nodiscard]] size_type size() const noexcept;</code> <code>[[nodiscard]] size_type max_size() const noexcept;</code> SpatialContainer Check dimensions <code>[[nodiscard]] size_type dimensions() const noexcept;</code> Get max/min values <code>dimension_type max_value(size_type dimension) const;</code> <code>dimension_type min_value(size_type dimension) const;</code> FrontContainer Reference points <code>key_type ideal() const;</code> <code>dimension_type ideal(size_type dimension) const;</code> <code>key_type nadir() const;</code> <code>dimension_type nadir(size_type dimension) const;</code> <code>key_type worst() const;</code> <code>dimension_type worst(size_type dimension) const;</code> Target directions <code>[[nodiscard]] bool is_minimization() const noexcept</code> <code>[[nodiscard]] bool is_maximization() const noexcept</code> <code>[[nodiscard]] bool is_minimization(size_t dimension) const noexcept</code> <code>[[nodiscard]] bool is_maximization(size_t dimension) const noexcept</code> ArchiveContainer <code>[[nodiscard]] size_t capacity() const noexcept</code> <code>size_type size_fronts() const noexcept</code> <p>Parameters</p> <ul> <li><code>dimension</code> - index of the dimension for which we want the minimum or maximum value</li> </ul> <p>Return value</p> <ul> <li><code>empty()</code>- <code>true</code> if and only if container (equivalent but more efficient than <code>begin() == end()</code>)</li> <li><code>size()</code> - The number of elements in the container</li> <li><code>max_size()</code> - An upper bound on the maximum number of elements the container can hold</li> <li><code>dimensions()</code> - Number of dimensions in the container (same as <code>M</code>, when <code>M != 0</code>)</li> <li><code>max_value(d)</code> - Maximum value in a given dimension <code>d</code></li> <li><code>min_value(d)</code> - Minimum value in a given dimension <code>d</code></li> <li><code>ideal()</code> - Key with best value possible in each dimension</li> <li><code>ideal(d)</code> - Best value possible in a given dimension <code>d</code></li> <li><code>nadir()</code> - Key with worst value possible in each dimension</li> <li><code>nadir(d)</code> - Worst value possible in a given dimension <code>d</code></li> <li><code>worst()</code> - Key with worst value possible in each dimension</li> <li><code>worst(d)</code> - Worst value possible in a given dimension <code>d</code></li> <li><code>is_minimization()</code>, <code>is_maximization()</code>: true if and only if all directions are minimization / maximization</li> <li><code>is_minimization(i)</code>, <code>is_maximization(i)</code>: true if and only if dimension <code>i</code> is minimization / maximization</li> <li><code>capacity()</code>: maximum number of elements in the archive</li> <li><code>size_front()</code>: number of fronts in the archive</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>For archives, the <code>nadir</code> and <code>worst</code> function will not necessarily return the same points and values because the worst point in a given dimension does have to match the worst value in the first front of the archive.</p> <p>Note</p> <p>All other requirements of fronts apply here.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>if (ar.empty()) {\n    std::cout &lt;&lt; \"Front is empty\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"Front is not empty\" &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; ar.size() &lt;&lt; \" elements in the front\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; ar.dimensions() &lt;&lt; \" dimensions\" &lt;&lt; std::endl;\nfor (size_t i = 0; i &lt; ar.dimensions(); ++i) {\n    if (ar.is_minimization(i)) {\n        std::cout &lt;&lt; \"Dimension \" &lt;&lt; i &lt;&lt; \" is minimization\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Dimension \" &lt;&lt; i &lt;&lt; \" is maximization\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"Best value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.ideal(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Min value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.min_value(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Max value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.max_value(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Best value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.ideal(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Nadir value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.nadir(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Worst value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.worst(i) &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; \"Ideal point: \" &lt;&lt; ar.ideal() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Nadir point: \" &lt;&lt; ar.nadir() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Worst point: \" &lt;&lt; ar.worst() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Capacity: \" &lt;&lt; ar.capacity() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Number of fronts: \" &lt;&lt; ar.size_fronts() &lt;&lt; std::endl;\n</code></pre> Python <pre><code>if ar:\n    print('Front is not empty')\nelse:\n    print('Front is empty')\n\nprint(len(ar), 'elements in the front')\nprint(ar.dimensions(), 'dimensions')\nfor i in range(ar.dimensions()):\n    if ar.is_minimization(i):\n        print('Dimension', i, ' is minimization')\n    else:\n        print('Dimension', i, ' is maximization')\n    print('Best value in dimension', i, ':', ar.ideal(i))\n    print('Min value in dimension', i, ':', ar.min_value(i))\n    print('Max value in dimension', i, ':', ar.max_value(i))\n    print('Best value in dimension', i, ':', ar.ideal(i))\n    print('Nadir value in dimension', i, ':', ar.nadir(i))\n    print('Worst value in dimension', i, ':', ar.worst(i))\n\nprint('Ideal point:', ar.ideal())\nprint('Nadir point:', ar.nadir())\nprint('Worst point:', ar.worst())\nprint('Capacity:', ar.capacity())\nprint('Number of fronts:', ar.size_fronts())\n</code></pre> Output <pre><code>Archive is not empty\n20 elements in the archive\n3 dimensions\nDimension 0  is minimization\nBest value in dimension 0 : -2.57664\nMin value in dimension 0 : -2.57664\nMax value in dimension 0 : 1.49101\nBest value in dimension 0 : -2.57664\nNadir value in dimension 0 : 1.49101\nWorst value in dimension 0 : 1.49101\nDimension 1  is maximization\nBest value in dimension 1 : 3.24052\nMin value in dimension 1 : -1.52034\nMax value in dimension 1 : 3.24052\nBest value in dimension 1 : 3.24052\nNadir value in dimension 1 : -1.52034\nWorst value in dimension 1 : -1.52034\nDimension 2  is minimization\nBest value in dimension 2 : -2.92346\nMin value in dimension 2 : -2.92346\nMax value in dimension 2 : 2.78224\nBest value in dimension 2 : -2.92346\nNadir value in dimension 2 : 2.78224\nWorst value in dimension 2 : 2.78224\nIdeal point: [-2.57664, 3.24052, -2.92346]\nNadir point: [1.49101, -1.52034, 2.78224]\nWorst point: [1.49101, -1.52034, 2.78224]\nCapacity: 1000\nNumber of fronts: 1\n</code></pre>"},{"location":"archive-container/constructors/","title":"Constructors","text":"Method Container + AllocatorAwareContainer Constructors <code>explicit archive(const allocator_type &amp;alloc = allocator_type())</code> <code>archive(const archive &amp;rhs)</code> <code>archive(const archive &amp;rhs, const allocator_type &amp;alloc)</code> <code>archive(archive &amp;&amp;rhs) noexcept</code> <code>archive(archive &amp;&amp;rhs, const allocator_type &amp;alloc) noexcept</code> AssociativeContainer + AllocatorAwareContainer Constructors <code>explicit archive(const C &amp;comp, const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; archive(InputIt first, InputIt last, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>archive(std::initializer_list&lt;value_type&gt; il, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; archive(InputIt first, InputIt last, const allocator_type &amp;alloc)</code> <code>archive(std::initializer_list&lt;value_type&gt; il, const allocator_type &amp;alloc)</code> FrontContainer Constructors <code>template &lt;class InputIt, class DirectionIt&gt; archive(InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir,       const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class DirectionIt&gt; archive(std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt&gt; archive(InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>archive(std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(),       const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>archive(std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt, class DirectionIt&gt; archive(InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class DirectionIt&gt; archive(std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class InputIt&gt; archive(InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>archive(std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>archive(std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> ArchiveContainer Constructors <code>explicit archive(size_type capacity, const allocator_type &amp;alloc = allocator_type())</code> <code>archive(size_type capacity, const archive &amp;rhs)</code> <code>archive(size_type capacity, const archive &amp;rhs, const allocator_type &amp;alloc)</code> <code>archive(size_type capacity, archive &amp;&amp;rhs) noexcept</code> <code>archive(size_type capacity, archive &amp;&amp;rhs, const allocator_type &amp;alloc) noexcept</code> <code>explicit archive(size_type capacity, const C &amp;comp, const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; archive(size_type capacity, InputIt first, InputIt last, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; archive(size_type capacity, InputIt first, InputIt last, const allocator_type &amp;alloc)</code> <code>archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, const allocator_type &amp;alloc)</code> <code>template &lt;class InputIt, class DirectionIt&gt; archive(size_type capacity, InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir,       const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class DirectionIt&gt; archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt&gt; archive(size_type capacity, InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(),       const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>archive(size_type capacity, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt, class DirectionIt&gt; archive(size_type capacity, InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class DirectionIt&gt; archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class InputIt&gt; archive(size_type capacity, InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>archive(size_type capacity, std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>archive(size_type capacity, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> AssociativeContainer + AllocatorAwareContainer Assignment <code>archive &amp;operator=(const archive &amp;rhs)</code> <code>archive &amp;operator=(archive &amp;&amp;rhs) noexcept</code> AssociativeContainer Assignment <code>archive &amp;operator=(std::initializer_list&lt;value_type&gt; il) noexcept</code> <p>Parameters</p> Parameter Description <code>alloc</code> allocator to use for all memory allocations of this container <code>comp</code> comparison function object to use for all comparisons of keys <code>first</code>, <code>last</code> the range to copy the elements from <code>rhs</code> another container to be used as source to initialize the elements of the container with <code>il</code> initializer list to initialize the elements of the container with <code>first_dir</code>, <code>last_dir</code> the range to copy the target directions from <code>il_dir</code> initializer list to initialize the target directions of the container with <code>capacity</code> maximum archive capacity <p>Requirements</p> Type requirements -<code>InputIt</code> and <code>DirectionIt</code> must meet the requirements of LegacyInputIterator. -<code>Compare</code> must meet the requirements of Compare. -<code>Allocator</code> must meet the requirements of Allocator. <p>Complexity</p> Method Complexity Empty constructor \\(O(1)\\) Copy constructor \\(O(mn)\\) Move constructor \\(O(1)\\) if <code>get_allocator() == rhs.get_allocator()</code> Construct from range, or assignment \\(O(m n \\log n)\\) <p>Notes</p> <p>An archive is also an adapter and an extension of spatial containers. An archive contains a <code>std::set</code> of fronts ordered by their dominance relationships. Unlike in a front, whenever we insert an element in the archive, it moves all elements dominated by the new element to higher fronts.</p> <p>The archive constructors overload all front constructors with an extra parameter for the archive capacity. If no maximum capacity for the archive is set, the capacity is set by default to \\(\\min(50 \\times 2^m, 100000)\\). The exponential factor \\(2^m\\) in this heuristic is meant to take the curse of dimensionality into account. </p> <p>The container makes sure the archive never has more elements than allowed by the <code>capacity</code> parameter. If the capacity exceeds, the container will remove the element in the most crowded regions of the worst front in the archive.</p> <p>Example</p> C++ <pre><code>#include &lt;pareto/archive.h&gt;\n#include &lt;pareto/kd_tree.h&gt;\n// ...\n// Constructing the default archive\nsize_t capacity = 1000;\narchive&lt;double, 3, unsigned&gt; ar(capacity, {min, max, min});\n// Constructing a archive based on kd trees\narchive&lt;double, 3, unsigned, kd_tree&lt;double, 3, unsigned&gt;&gt; ar2(capacity, {min, max, min});\n</code></pre> Python <pre><code>import pareto\n# ...\n# Constructing the default archive\ncapacity = 1000\nar = pareto.archive(capacity, ['min', 'max', 'min']);\n# Constructing a archive based on kd trees\nar2 = pareto.kd_archive(capacity, ['min', 'max', 'min']);\n</code></pre> <p>Tip</p> <p>If you need to plot these archives, <code>examples/matplotpp_example.cpp</code> includes an example that uses Matplot++. In Python, you can use Matplotlib.</p>"},{"location":"archive-container/dominance-relationships/","title":"Dominance Relationships","text":"Method FrontContainer Archive-Point Dominance <code>bool dominates(const key_type &amp;p)</code> <code>bool strongly_dominates(const key_type &amp;p) const</code> <code>bool is_partially_dominated_by(const key_type &amp;p) const</code> <code>bool is_completely_dominated_by(const key_type &amp;p) const</code> <code>bool non_dominates(const key_type &amp;p) const</code> Archive-Front Dominance <code>bool dominates(const front &amp;P) const</code> <code>bool strongly_dominates(const front &amp;P) const</code> <code>bool is_partially_dominated_by(const front &amp;P) const</code> <code>bool is_completely_dominated_by(const front &amp;P) const</code> <code>bool non_dominates(const front &amp;P) const</code> Archive-Archive Dominance <code>bool dominates(const archive &amp;A) const</code> <code>bool strongly_dominates(const archive &amp;A) const</code> <code>bool is_partially_dominated_by(const archive &amp;A) const</code> <code>bool is_completely_dominated_by(const archive &amp;A) const</code> <code>bool non_dominates(const archive &amp;A) const</code> <p>Parameters</p> <ul> <li><code>p</code> - point we are checking for dominance</li> <li><code>P</code> - front we are checking for dominance</li> <li><code>A</code> - archive we are checking for dominance</li> </ul> <p>Return value</p> <ul> <li><code>bool</code>- <code>true</code> if and only if the point <code>p</code> (or front <code>P</code>, or archive <code>A</code>) is dominated, is strongly dominated, partially dominates, completely dominates, or non-dominantes <code>*this</code></li> </ul> <p>Complexity</p> <ul> <li><code>is_completely_dominated_by</code>:  \\(O(1)\\) for points and \\(O(n)\\) for fronts</li> <li>All others:  \\(O(m \\log n)\\) for points and \\(O(m n \\log n)\\) for fronts</li> </ul> <p>Notes</p> <p>The dominance between archives is defined in terms of the first front in the archive.</p> <p>Note</p> <p>See the section fronts / dominance relationships for more details </p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>// Point-point dominance\nusing point_type = archive&lt;double, 3, unsigned&gt;::key_type;\npoint_type p1({0, 0, 0});\npoint_type p2({1, 1, 1});\nstd::vector&lt;bool&gt; is_minimization = {true, false, true};\nstd::cout &lt;&lt; (p1.dominates(p2, is_minimization) ? \"p1 dominates p2\" : \"p1 does not dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (p1.strongly_dominates(p2, is_minimization) ? \"p1 strongly dominates p2\" : \"p1 does not strongly dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (p1.non_dominates(p2, is_minimization) ? \"p1 non-dominates p2\" : \"p1 does not non-dominate p2\") &lt;&lt; std::endl;\n\n// Archive-point dominance\nstd::cout &lt;&lt; (ar.dominates(p2) ? \"ar dominates p2\" : \"ar does not dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.strongly_dominates(p2) ? \"ar strongly dominates p2\" : \"ar does not strongly dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.non_dominates(p2) ? \"ar non-dominates p2\" : \"ar does not non-dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.is_partially_dominated_by(p2) ? \"ar is partially dominated by p2\" : \"ar is not is partially dominated by p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.is_completely_dominated_by(p2) ? \"ar is completely dominated by p2\" : \"ar is not is completely dominated by p2\") &lt;&lt; std::endl;\n\n// Archive-archive dominance\narchive&lt;double, 3, unsigned&gt; ar2({min, max, min});\nfor (const auto&amp; [p,v]: ar) {\n    ar2[point_type({p[0] - 1, p[1] + 1, p[2] - 1})] = v;\n}\nstd::cout &lt;&lt; (ar.dominates(ar2) ? \"ar dominates ar2\" : \"ar does not dominate ar2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.strongly_dominates(ar2) ? \"ar strongly dominates ar2\" : \"ar does not strongly dominate ar2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.non_dominates(ar2) ? \"ar non-dominates ar2\" : \"ar does not non-dominate ar2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.is_partially_dominated_by(ar2) ? \"ar is partially dominated by ar2\" : \"ar is not is partially dominated by ar2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (ar.is_completely_dominated_by(ar2) ? \"ar is completely dominated by ar2\" : \"ar is not is completely dominated by ar2\") &lt;&lt; std::endl;\n</code></pre> Python <pre><code># Point-point dominance\np1 = pareto.point([0, 0, 0])\np2 = pareto.point([1, 1, 1])\nis_minimization = [True, False, True]\nprint('p1 dominates p2' if p1.dominates(p2, is_minimization) else 'p1 does not dominate p2')\nprint('p1 strongly dominates p2' if p1.strongly_dominates(p2, is_minimization) else 'p1 does not strongly dominate p2')\nprint('p1 non-dominates p2' if p1.non_dominates(p2, is_minimization) else 'p1 does not non-dominate p2')\n\n# Archive-point dominance\nprint('ar dominates p2' if ar.dominates(p2) else 'ar does not dominate p2')\nprint('ar strongly dominates p2' if ar.strongly_dominates(p2) else 'ar does not strongly dominate p2')\nprint('ar non-dominates p2' if ar.non_dominates(p2) else 'ar does not non-dominate p2')\nprint('ar is partially dominated by p2' if ar.is_partially_dominated_by(p2) else 'ar is not is partially dominated by p2')\nprint('ar is completely dominated by p2' if ar.is_completely_dominated_by(p2) else 'ar is not is completely dominated by p2')\n\n# Archive-archive dominance\nar2 = pareto.archive(['min', 'max', 'min'])\nfor [p, v] in ar:\n    ar2[pareto.point([p[0] - 1, p[1] + 1, p[2] - 1])] = v\n\nprint('ar dominates ar2' if ar.dominates(ar2) else 'ar does not dominate ar2')\nprint('ar strongly dominates ar2' if ar.strongly_dominates(ar2) else 'ar does not strongly dominate ar2')\nprint('ar non-dominates ar2' if ar.non_dominates(ar2) else 'ar does not non-dominate ar2')\nprint('ar is partially dominated by ar2' if ar.is_partially_dominated_by(ar2) else 'ar is not is partially dominated by ar2')\nprint('ar is completely dominated by ar2' if ar.is_completely_dominated_by(ar2) else 'ar is not is completely dominated by ar2')\n</code></pre> Output <pre><code>p1 does not dominate p2\np1 does not strongly dominate p2\np1 non-dominates p2\nar dominates p2\nar strongly dominates p2\nar does not non-dominate p2\nar is not is partially dominated by p2\nar is not is completely dominated by p2\nar does not dominate ar2\nar does not strongly dominate ar2\nar does not non-dominate ar2\nar is partially dominated by ar2\nar is completely dominated by ar2\n</code></pre>"},{"location":"archive-container/element-access/","title":"Element Access","text":"Method MapContainer Access and throw exception if it doesn't exist <code>mapped_type &amp;at(const key_type &amp;k);</code> <code>const mapped_type &amp;at(const key_type &amp;k) const;</code> Access and create new element if it doesn't exist <code>mapped_type &amp;operator[](https://github.com/alandefreitas/pareto/blob/master/);</code> <code>mapped_type &amp;operator[](https://github.com/alandefreitas/pareto/blob/master/);</code> <code>template &lt;typename... Targs&gt; mapped_type &amp;operator()(const dimension_type &amp;x1, const Targs &amp;...xs);</code> <p>Parameters</p> <ul> <li><code>k</code> - the key of the element to find</li> <li><code>x1</code> - the value of the element to find in the first dimension</li> <li><code>xs</code> - the value of the element to find in other dimensions</li> </ul> <p>Return value</p> <p>A reference to the element associated with that key.</p> <p>Exceptions</p> <p><code>std::out_of_range</code> if the container does not have an element with the specified <code>key</code></p> <p>Complexity</p> \\[ O(m \\log n) \\] <p>Notes</p> <p>Unlike in a <code>pareto::spatial_map</code>, the <code>insert</code> operation for archives is allowed to fail when the new element is already dominated by all fronts and exceeds the maximum capacity of the archive. In this case, the <code>operator[]</code> will return a reference to a placeholder that is not ultimately inserted in the front.</p> <p>Info</p> <p>See the section on spatial containers / element access for more information.</p> <p>Example</p> C++ <pre><code>archive&lt;double, 3, unsigned&gt; ar({min, max, min});\n// Set some values\nar(-2.57664, -1.52034, 0.600798) = 17;\nar(-2.14255, -0.518684, -2.92346) = 32;\nar(-1.63295, 0.912108, -2.12953) = 36;\nar(-0.653036, 0.927688, -0.813932) = 13;\nar(-0.508188, 0.871096, -2.25287) = 32;\nar(-2.55905, -0.271349, 0.898137) = 6;\nar(-2.31613, -0.219302, 0) = 8;\nar(-0.639149, 1.89515, 0.858653) = 10;\nar(-0.401531, 2.30172, 0.58125) = 39;\nar(0.0728106, 1.91877, 0.399664) = 25;\nar(-1.09756, 1.33135, 0.569513) = 20;\nar(-0.894115, 1.01387, 0.462008) = 11;\nar(-1.45049, 1.35763, 0.606019) = 17;\nar(0.152711, 1.99514, -0.112665) = 13;\nar(-2.3912, 0.395611, 2.78224) = 11;\nar(-0.00292544, 1.29632, -0.578346) = 20;\nar(0.157424, 2.30954, -1.23614) = 6;\nar(0.453686, 1.02632, -2.24833) = 30;\nar(0.693712, 1.12267, -1.37375) = 12;\nar(1.49101, 3.24052, 0.724771) = 24;\n\n// Access value\nif (ar.contains({1.49101, 3.24052, 0.724771})) {\n    std::cout &lt;&lt; \"Element access: \" &lt;&lt; ar(1.49101, 3.24052, 0.724771) &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"{1.49101, 3.24052, 0.724771} was dominated\" &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>ar = pareto.archive()\n# Set some values\nar[-2.57664, -1.52034, 0.600798] = 17\nar[-2.14255, -0.518684, -2.92346] = 32\nar[-1.63295, 0.912108, -2.12953] = 36\nar[-0.653036, 0.927688, -0.813932] = 13\nar[-0.508188, 0.871096, -2.25287] = 32\nar[-2.55905, -0.271349, 0.898137] = 6\nar[-2.31613, -0.219302, 0] = 8\nar[-0.639149, 1.89515, 0.858653] = 10\nar[-0.401531, 2.30172, 0.58125] = 39\nar[0.0728106, 1.91877, 0.399664] = 25\nar[-1.09756, 1.33135, 0.569513] = 20\nar[-0.894115, 1.01387, 0.462008] = 11\nar[-1.45049, 1.35763, 0.606019] = 17\nar[0.152711, 1.99514, -0.112665] = 13\nar[-2.3912, 0.395611, 2.78224] = 11\nar[-0.00292544, 1.29632, -0.578346] = 20\nar[0.157424, 2.30954, -1.23614] = 6\nar[0.453686, 1.02632, -2.24833] = 30\nar[0.693712, 1.12267, -1.37375] = 12\nar[1.49101, 3.24052, 0.724771] = 24\n\n# Access value\nif [1.49101, 3.24052, 0.724771] in ar:\n    print('Element access:', ar[1.49101, 3.24052, 0.724771])\nelse:\n    print(\"[1.49101, 3.24052, 0.724771] was dominated\")\n</code></pre> Output <pre><code>Element access: 24\n</code></pre>"},{"location":"archive-container/indicators/","title":"Indicators","text":"Method FrontContainer Exact Hypervolume <code>dimension_type hypervolume() const</code> <code>dimension_type hypervolume(key_type reference_point) const</code> Monte-Carlo Hypervolume <code>dimension_type hypervolume(size_t sample_size) const</code> <code>dimension_type hypervolume(size_t sample_size, const key_type &amp;reference_point) const</code> Cardinality <code>double coverage(const front &amp;rhs) const</code> <code>double coverage_ratio(const front &amp;rhs) const</code> Convergence Indicators <code>double gd(const front &amp;reference) const</code> <code>double igd(const front &amp;reference) const</code> <code>double igd_plus(const front &amp;reference) const</code> <code>double hausdorff(const front &amp;reference) const</code> Standard deviation of Convergence Indicators <code>double std_gd(const front &amp;reference) const</code> <code>double std_igd(const front &amp;reference) const</code> <code>double std_igd_plus(const front &amp;reference) const</code> First Front Distribution <code>[[nodiscard]] double uniformity() const</code> <code>[[nodiscard]] double average_distance() const</code> <code>[[nodiscard]] double average_nearest_distance(size_t k = 5) const</code> <code>[[nodiscard]] double average_crowding_distance() const</code> Point Distribution <code>double crowding_distance(const_iterator element, key_type worst_point, key_type ideal_point) const</code> <code>double crowding_distance(const_iterator element) const</code> <code>double crowding_distance(const key_type &amp;point) const</code> Conflict / Harmony <code>dimension_type direct_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double maxmin_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double conflict(const size_t a, const size_t b) const</code> Normalized Conflict / Harmony <code>[[nodiscard]] double normalized_direct_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double normalized_maxmin_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double normalized_conflict(const size_t a, const size_t b) const</code> ArchiveContainer Cardinality <code>double coverage(const front &amp;rhs) const</code> <code>double coverage_ratio(const front &amp;rhs) const</code> Convergence Indicators <code>double gd(const front &amp;reference) const</code> <code>double igd(const front &amp;reference) const</code> <code>double igd_plus(const front &amp;reference) const</code> <code>double hausdorff(const front &amp;reference) const</code> Standard deviation of Convergence Indicators <code>double std_gd(const front &amp;reference) const</code> <code>double std_igd(const front &amp;reference) const</code> <code>double std_igd_plus(const front &amp;reference) const</code> <p>Parameters</p> <ul> <li><code>reference_point</code> - point used as reference for the hypervolume calculation. When not provided, it defaults to the <code>nadir()</code> point.</li> <li><code>sample_size</code> - number of samples for the hypervolume estimate</li> <li><code>rhs</code> - front or archive being compared</li> <li><code>reference</code> - Target front. An estimate of the best front possible for the problem.</li> <li><code>k</code> - number of nearest elements to consider</li> <li><code>element</code> - element for which we want the crowding distance (see below)</li> <li><code>key_type</code> - point for which we want the crowding distance (see below)</li> <li><code>worst_point</code>, <code>ideal_point</code> - reference extreme points for the crowding distance</li> <li><code>a</code>, <code>b</code> - dimension indices</li> </ul> <p>Return value</p> <ul> <li>(see section Indicators for fronts)</li> </ul> <p>Complexity</p> <ul> <li>(see section Indicators for fronts)</li> </ul> <p>Notes</p> <p>The archive indicators use their first front as reference.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>// Hypervolume\nstd::cout &lt;&lt; \"Exact hypervolume: \" &lt;&lt; ar.hypervolume(ar.nadir()) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Hypervolume approximation (10000 samples): \" &lt;&lt; ar.hypervolume(10000, ar.nadir()) &lt;&lt; std::endl;\n\n// Coverage\nstd::cout &lt;&lt; \"C-metric: \" &lt;&lt; ar.coverage(ar2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Coverage ratio: \" &lt;&lt; ar.coverage_ratio(ar2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"C-metric: \" &lt;&lt; ar2.coverage(ar) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Coverage ratio: \" &lt;&lt; ar2.coverage_ratio(ar) &lt;&lt; std::endl;\n\n// Convergence\narchive&lt;double, 3, unsigned&gt; ar_star({min, max, min});\nfor (const auto &amp;[p,v] : ar) {\n    ar_star(p[0] - 1.0, p[1] + 1.0, p[2] - 1.0) = v;\n}\nassert(ar.is_completely_dominated_by(ar_star));\n\nstd::cout &lt;&lt; \"GD: \" &lt;&lt; ar.gd(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDGD: \" &lt;&lt; ar.std_gd(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"IGD: \" &lt;&lt; ar.igd(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDGD: \" &lt;&lt; ar.std_igd(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Hausdorff: \" &lt;&lt; ar.hausdorff(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"IGD+: \" &lt;&lt; ar.igd_plus(ar_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDIGD+: \" &lt;&lt; ar.std_igd_plus(ar_star) &lt;&lt; std::endl;\n\n// Distribution\nstd::cout &lt;&lt; \"Uniformity: \" &lt;&lt; ar.uniformity() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average distance: \" &lt;&lt; ar.average_distance() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average nearest distance: \" &lt;&lt; ar.average_nearest_distance(5) &lt;&lt; std::endl;\nauto near_origin = ar.find_nearest({0.0, 0.0, 0.0});\nstd::cout &lt;&lt; \"Crowding distance: \" &lt;&lt; ar.crowding_distance(near_origin) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average crowding distance: \" &lt;&lt; ar.average_crowding_distance() &lt;&lt; std::endl;\n\n// Correlation\nstd::cout &lt;&lt; \"Direct conflict(0,1): \" &lt;&lt; ar.direct_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized direct conflict(0,1): \" &lt;&lt; ar.normalized_direct_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Maxmin conflict(0,1): \" &lt;&lt; ar.maxmin_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized maxmin conflict(0,1): \" &lt;&lt; ar.normalized_maxmin_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Non-parametric conflict(0,1): \" &lt;&lt; ar.conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized conflict(0,1): \" &lt;&lt; ar.normalized_conflict(0,1) &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"Direct conflict(1,2): \" &lt;&lt; ar.direct_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized direct conflict(1,2): \" &lt;&lt; ar.normalized_direct_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Maxmin conflict(1,2): \" &lt;&lt; ar.maxmin_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized maxmin conflict(1,2): \" &lt;&lt; ar.normalized_maxmin_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Non-parametric conflict(1,2): \" &lt;&lt; ar.conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized conflict(1,2): \" &lt;&lt; ar.normalized_conflict(1,2) &lt;&lt; std::endl;\n</code></pre> Python <pre><code># Hypervolume\nprint('Exact hypervolume:', ar.hypervolume(ar.nadir()))\nprint('Hypervolume approximation (10000 samples):', ar.hypervolume(10000, ar.nadir()))\n\n# Coverage\nprint('C-metric:', ar.coverage(ar2))\nprint('Coverage ratio:', ar.coverage_ratio(ar2))\nprint('C-metric:', ar2.coverage(ar))\nprint('Coverage ratio:', ar2.coverage_ratio(ar))\n\n# Convergence\nar_star = pareto.archive(['min', 'max', 'min'])\nfor [p, v] in ar:\n    ar_star[p[0] - 1.0, p[1] + 1.0, p[2] - 1.0] = v\n\nprint('GD:', ar.gd(ar_star))\nprint('STDGD:', ar.std_gd(ar_star))\nprint('IGD:', ar.igd(ar_star))\nprint('STDGD:', ar.std_igd(ar_star))\nprint('Hausdorff:', ar.hausdorff(ar_star))\nprint('IGD+:', ar.igd_plus(ar_star))\nprint('STDIGD+:', ar.std_igd_plus(ar_star))\n\n# Distribution\nprint(\"Uniformity:\", ar.uniformity())\nprint(\"Average distance:\", ar.average_distance())\nprint(\"Average nearest distance:\", ar.average_nearest_distance(5))\nnear_origin = next(ar.find_nearest(pareto.point([0.0, 0.0])))\nprint(\"Crowding distance:\", ar.crowding_distance(near_origin[0]))\nprint(\"Average crowding distance:\", ar.average_crowding_distance())\n\n# Correlation\nprint('Direct conflict(0,1):', ar.direct_conflict(0, 1))\nprint('Normalized direct conflict(0,1):', ar.normalized_direct_conflict(0, 1))\nprint('Maxmin conflict(0,1):', ar.maxmin_conflict(0, 1))\nprint('Normalized maxmin conflict(0,1):', ar.normalized_maxmin_conflict(0, 1))\nprint('Non-parametric conflict(0,1):', ar.conflict(0, 1))\nprint('Normalized conflict(0,1):', ar.normalized_conflict(0, 1))\n\nprint('Direct conflict(1,2):', ar.direct_conflict(1, 2))\nprint('Normalized direct conflict(1,2):', ar.normalized_direct_conflict(1, 2))\nprint('Maxmin conflict(1,2):', ar.maxmin_conflict(1, 2))\nprint('Normalized maxmin conflict(1,2):', ar.normalized_maxmin_conflict(1, 2))\nprint('Non-parametric conflict(1,2):', ar.conflict(1, 2))\nprint('Normalized conflict(1,2):', ar.normalized_conflict(1, 2))\n</code></pre> Output <pre><code>Exact hypervolume: 55.4029\nHypervolume approximation (10000 samples): 56.0535\nC-metric: 0\nCoverage ratio: 0\nC-metric: 1\nCoverage ratio: inf\nGD: 1.54786\nSTDGD: 0.0465649\nIGD: 1.52137\nSTDGD: 0.0472864\nHausdorff: 1.54786\nIGD+: 1.48592\nSTDIGD+: 0.0522492\nUniformity: 0.355785\nAverage distance: 2.75683\nAverage nearest distance: 1.45177\nCrowding distance: 3.04714\nAverage crowding distance: 4.04349\nDirect conflict(0,1): 34.3539\nNormalized direct conflict(0,1): 0.360795\nMaxmin conflict(0,1): 7.77615\nNormalized maxmin conflict(0,1): 0.388808\nNon-parametric conflict(0,1): 184\nNormalized conflict(0,1): 0.92\nDirect conflict(1,2): 32.0107\nNormalized direct conflict(1,2): 0.280515\nMaxmin conflict(1,2): 5.85805\nNormalized maxmin conflict(1,2): 0.292903\nNon-parametric conflict(1,2): 146\nNormalized conflict(1,2): 0.73\n</code></pre>"},{"location":"archive-container/iterators/","title":"Iterators","text":"Method MultimapContainer Get constant iterators <code>const_iterator begin() const noexcept;</code> <code>const_iterator end() const noexcept;</code> <code>const_iterator cbegin() const noexcept;</code> <code>const_iterator cend() const noexcept;</code> Get iterators <code>iterator begin() noexcept;</code> <code>iterator end() noexcept;</code> Get reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; rbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; rend() const noexcept;</code> <code>std::reverse_iterator&lt;iterator&gt; rbegin() noexcept</code>; <code>std::reverse_iterator&lt;iterator&gt; rend() noexcept;</code> Get constant reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; crbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; crend() const noexcept;</code> ArchiveContainer Get constant iterators to front set <code>front_set_type::const_iterator begin_front() const noexcept;</code> <code>front_set_type::const_iterator end_front() const noexcept;</code> <code>front_set_type::const_iterator cbegin_front() const noexcept;</code> <code>front_set_type::const_iterator cend_front() const noexcept;</code> Get iterators to front set <code>front_set_type::iterator begin_front() noexcept;</code> <code>front_set_type::iterator end_front() noexcept;</code> Get reverse iterators to front set <code>std::reverse_iterator&lt;front_set_type::const_iterator&gt; rbegin_front() const noexcept;</code> <code>std::reverse_iterator&lt;front_set_type::const_iterator&gt; rend_front() const noexcept;</code> <code>std::reverse_iterator&lt;front_set_type::iterator&gt; rbegin_front() noexcept</code>; <code>std::reverse_iterator&lt;front_set_type::iterator&gt; rend_front() noexcept;</code> Get constant reverse iterators to front set <code>std::reverse_iterator&lt;front_set_type::const_iterator&gt; crbegin_front() const noexcept;</code> <code>std::reverse_iterator&lt;front_set_type::const_iterator&gt; crend_front() const noexcept;</code> <p>Return value</p> <ul> <li><code>begin()</code> - Iterators to the first element in the container</li> <li><code>end()</code> - Iterator to the past-the-end element in the container</li> <li><code>begin_front()</code> - Iterators to the first front in the archive</li> <li><code>end_front()</code> - Iterator to the past-the-end front in the archive</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>The <code>begin()</code> and <code>begin_front()</code> functions provide two ways to access the elements in the archive: (i) element by element, or (ii) front by front.</p> <p>Info</p> <p>See the section on spatial containers / iterators for more information.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>std::cout &lt;&lt; \"Iterators:\" &lt;&lt; std::endl;\nfor (const auto&amp; [point, value]: ar) {\n    std::cout &lt;&lt; point &lt;&lt; \" -&gt; \" &lt;&lt; value &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; \"Reversed Iterators:\" &lt;&lt; std::endl;\nfor (auto it = ar.rbegin(); it != ar.rend(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; \"Front Iterators:\" &lt;&lt; std::endl;\nfor (auto it = ar.begin_front(); it != ar.end_front(); ++it) {\n    std::cout &lt;&lt; \"Front with \" &lt;&lt; it-&gt;size() &lt;&lt; \" elements\" &lt;&lt; std::endl;\n    for (const auto &amp;[k, v] : *it) {\n        std::cout &lt;&lt; k &lt;&lt; \" -&gt; \" &lt;&lt; v &lt;&lt; std::endl;\n    }\n}\n</code></pre> Python <pre><code>print('Iterators')\nfor [point, value] in ar:\n    print(point, '-&gt;', value)\n\nprint('Reversed Iterators')\nfor [point, value] in reversed(ar):\n    print(point, '-&gt;', value)\n\nprint('Front Iterators')\nfor pf in ar.fronts():\n    print('Front with', len(pf), 'elements')\n    for [point, value] in pf:\n        print(point, '-&gt;', value)\n</code></pre> Output <pre><code>Iterators:\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[1.49101, 3.24052, 0.724771] -&gt; 24\nReversed Iterators:\n[1.49101, 3.24052, 0.724771] -&gt; 24\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.31613, -0.219302, 0] -&gt; 8\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-2.14255, -0.518684, -2.92346] -&gt; 32\nFront Iterators:\nFront with 20 elements\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[1.49101, 3.24052, 0.724771] -&gt; 24\n</code></pre>"},{"location":"archive-container/lookup-and-queries/","title":"Lookup and Queries","text":"Method Multimap Returns the number of elements matching specific key <code>size_type count(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; size_type count(const L &amp;p) const</code> Finds element with specific key <code>iterator find(const key_type &amp;p);</code> <code>const_iterator find(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; iterator find(const L &amp;p)</code> <code>template &lt;class L&gt; const_iterator find(const L &amp;p) const;</code> Checks if the container contains element with specific key <code>bool contains(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; bool contains(const L &amp;p) const;</code> SpatialContainer Get iterator to first element that passes the predicates <code>const_iterator find(const predicate_list_type &amp;ps) const noexcept;</code> <code>iterator find(const predicate_list_type &amp;ps) noexcept;</code> Find intersection between point and container <code>iterator find_intersection(const key_type &amp;p);</code> <code>const_iterator find_intersection(const key_type &amp;p) const;</code> Find intersection between container and query box <code>iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find points inside a query box (excluding borders) <code>iterator find_within(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_within(const key_type &amp;lb, const key_type &amp;ub) const</code> Find points outside a query box <code>iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find the elements closest to a point <code>iterator find_nearest(const key_type &amp;p);</code> <code>const_iterator find_nearest(const key_type &amp;p) const;</code> <code>iterator find_nearest(const key_type &amp;p, size_t k);</code> <code>const_iterator find_nearest(const key_type &amp;p, size_t k) const;</code> <code>iterator find_nearest(const box_type &amp;b, size_t k);</code> <code>const_iterator find_nearest(const box_type &amp;b, size_t k) const;</code> Find min/max elements <code>iterator max_element(size_t dimension)</code> <code>const_iterator max_element(size_t dimension) const</code> <code>iterator min_element(size_t dimension)</code> <code>const_iterator min_element(size_t dimension) const</code> FrontContainer Find sets of dominated elements <code>const_iterator find_dominated(const key_type &amp;p) const</code> <code>iterator find_dominated(const key_type &amp;p)</code> Find nearest point excluding \\(p\\) <code>const_iterator find_nearest_exclusive(const key_type &amp;p) const</code> <code>iterator find_nearest_exclusive(const key_type &amp;p)</code> Find extreme elements <code>const_iterator ideal_element(size_t d) const</code> <code>iterator ideal_element(size_t d)</code> <code>const_iterator nadir_element(size_t d) const</code> <code>iterator nadir_element(size_t d)</code> <code>const_iterator worst_element(size_t d) const</code> <code>iterator worst_element(size_t d)</code> ArchiveContainer Find sets of dominated elements <code>front_set_type::const_iterator find_front(const key_type &amp;p) const</code> <code>front_set_type::iterator find_front(const key_type &amp;p)</code> <p>Parameters</p> <ul> <li><code>ps</code> - a list of predicates</li> <li><code>p</code> - a point of type <code>key_value</code> or convertible to <code>key_value</code></li> <li><code>lb</code> and <code>ub</code> - lower and upper bounds of the query box</li> <li><code>k</code> - number of nearest elements</li> </ul> <p>Return value</p> <ul> <li><code>count()</code>: <code>size_type</code>: number of elements with a given key</li> <li><code>container()</code>: <code>bool</code>: <code>true</code> if and only if the container contains an element with the given key <code>p</code></li> <li><code>find_*</code>: <code>iterator</code> and <code>const_iterator</code> - Iterator to the first element that passes the query predicates</li> <li><code>find</code> returns a normal iterator</li> <li>all other <code>find_*</code> functions return a query iterator (see below)</li> <li><code>size_type</code> - Number of elements erased</li> <li><code>front_set_type::const_iterator</code> - find first front not dominated by <code>p</code></li> </ul> <p>Complexity</p> <p>Let \\(|A|\\) denote the number of fronts in the archive:</p> <ul> <li><code>find_front</code> - \\(O(\\log |A|)\\)</li> <li>others - O(m |A| \\log n)</li> </ul> <p>Due to the curse of dimensionality, we usually expect that \\(|A| \\ll n\\), especially as \\(m\\) grows.</p> <p>Notes</p> <p>The function <code>find_front</code> will look for the first front that does not dominate the element <code>p</code>. This is an important sub-component of the insertion algorithm.</p> <p>Note</p> <p>All other definitions and requirements of a FrontContainer also apply here.</p> <p>Examples</p> <p>Continuing from the previous example:</p> C++ <pre><code>for (auto it = ar.find_intersection(ar.ideal(), {-2.3912, 0.395611, 2.78224}); it != ar.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = ar.find_within(ar.ideal(), {-2.3912, 0.395611, 2.78224}); it != ar.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = ar.find_disjoint(ar.worst(), {+0.71, +1.19, +0.98}); it != ar.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = ar.find_nearest({-2.3912, 0.395611, 2.78224}, 2); it != ar.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nauto it_near = ar.find_nearest({2.5, 2.5, 2.5});\nstd::cout &lt;&lt; it_near-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it_near-&gt;second &lt;&lt; std::endl;\nfor (auto it = ar.find_dominated({-10, +10, -10}); it != ar.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (size_t i = 0; i &lt; ar.dimensions(); ++i) {\n    std::cout &lt;&lt; \"Ideal element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.ideal_element(i)-&gt;first &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Nadir element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.nadir_element(i)-&gt;first &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Worst element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; ar.worst_element(i)-&gt;first &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>for [k, v] in ar.find_intersection(ar.ideal(), pareto.point([-2.3912, 0.395611, 2.78224])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in ar.find_within(ar.ideal(), pareto.point([-2.3912, 0.395611, 2.78224])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in ar.find_disjoint(ar.worst(), pareto.point([+0.71, +1.19, +0.98])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in ar.find_nearest(pareto.point([-2.3912, 0.395611, 2.78224]), 2):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in ar.find_nearest(pareto.point([2.5, 2.5, 2.5])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in ar.find_dominated(pareto.point([-10, +10, -10])):\n    print(k, \"-&gt;\", v)\n\nfor i in range(ar.dimensions()):\n    print('Ideal element in dimension', i, ': ', ar.ideal_element(i)[0])\n    print('Nadir element in dimension', i, ': ', ar.nadir_element(i)[0])\n    print('Worst element in dimension', i, ': ', ar.worst_element(i)[0])\n</code></pre> Output <pre><code>[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\nIdeal element in dimension 0: [-2.57664, -1.52034, 0.600798]\nNadir element in dimension 0: [0.693712, 1.12267, -1.37375]\nWorst element in dimension 0: [0.693712, 1.12267, -1.37375]\nIdeal element in dimension 1: [0.157424, 2.30954, -1.23614]\nNadir element in dimension 1: [-2.57664, -1.52034, 0.600798]\nWorst element in dimension 1: [-2.57664, -1.52034, 0.600798]\nIdeal element in dimension 2: [-2.14255, -0.518684, -2.92346]\nNadir element in dimension 2: [-2.3912, 0.395611, 2.78224]\nWorst element in dimension 2: [-2.3912, 0.395611, 2.78224]\n</code></pre>"},{"location":"archive-container/modifiers/","title":"Modifiers","text":"Method Container + AllocatorAwareContainer Exchanges the contents of the container with those of <code>rhs</code> <code>void swap(kd_tree &amp;rhs) noexcept;</code> Multimap Erases all elements from the container <code>void clear();</code> Inserts element(s) into the container <code>iterator insert(const value_type &amp;v);</code> <code>iterator insert(value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(P &amp;&amp;v);</code> <code>iterator insert(iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(const_iterator hint, P &amp;&amp;v);</code> <code>template &lt;class Inputiterator&gt; void insert(Inputiterator first, Inputiterator last);</code> <code>void insert(std::initializer_list&lt;value_type&gt; init);</code> Inserts a new element into the container constructed in-place with the given <code>args</code> <code>template &lt;class... Args&gt; iterator emplace(Args &amp;&amp;...args);</code> <code>template &lt;class... Args&gt; iterator emplace_hint(const_iterator, Args &amp;&amp;...args);</code> Removes specified elements from the container <code>iterator erase(const_iterator position);</code> <code>iterator erase(iterator position);</code> <code>iterator erase(const_iterator first, const_iterator last);</code> <code>size_type erase(const key_type &amp;k);</code> Attempts to extract (\"splice\") each element in <code>source</code> and insert it into <code>*this</code> <code>void merge(archive &amp;source) noexcept;</code> <code>void merge(archive &amp;&amp;source) noexcept;</code> ArchiveContainer <code>void merge(front_type &amp;source) noexcept;</code> <code>void merge(front_type &amp;&amp;source) noexcept;</code> <code>void resize(size_t new_size);</code> <p>Parameters</p> <ul> <li><code>rhs</code> - container to exchange the contents with</li> <li><code>v</code> - element value to insert</li> <li><code>first</code>, <code>last</code> - range of elements to insert/erase</li> <li><code>init</code> - initializer list to insert the values from</li> <li><code>hint</code> - iterator, used as a suggestion as to where to start the search</li> <li><code>position</code> - iterator pointer to element to erase</li> <li><code>k</code> - key value of the elements to remove</li> <li><code>source</code> - container to get elements from</li> <li><code>new_size</code> - new capacity of the archive</li> </ul> <p>Return value</p> <ul> <li><code>iterator</code> - Iterator to the new element (<code>insert</code>) or following the last removed element (<code>erase</code>)</li> <li><code>size_type</code> - Number of elements erased</li> </ul> <p>Complexity</p> <ul> <li><code>insert</code>, <code>emplace</code>,  <code>erase</code>: \\(O(m \\log n)\\)</li> <li><code>swap</code>: \\(O(1)\\)</li> <li><code>merge</code>: \\(O(mn)\\)</li> </ul> <p>Notes</p> <p>Manipulating archives does not have the same side effects as manipulating fronts:</p> <p>1) The insertion operator will move any points that are worse than the new point to higher fronts.  2) The removal operator will bring any previously dominated elements closer to the best fronts.</p> <p>When <code>resize(size_t new_size)</code> is called with a new size smaller than the current number of elements in the archive, the archive if pruned. The pruning algorithm will remove the last front in the archive until the new size is achieved. If the last front has more elements that we need to remove, up to \\(2 * \\log_2 capacity\\) elements are removed by their crowding distances and other elements are removed randomly.  </p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>ar.insert({ {1.49101, 3.24052, 0.724771}, 24});\nar.erase({1.49101, 3.24052, 0.724771});\n</code></pre> Python <pre><code>ar.insert([pareto.point([1.49101, 3.24052, 0.724771]), 24])\ndel ar[1.49101, 3.24052, 0.724771]\n</code></pre>"},{"location":"archive-container/observers/","title":"Observers","text":"Method Multimap Returns the function that compares keys <code>key_compare key_comp() const noexcept;</code> Returns the function that compares keys in objects of type value_type <code>value_compare value_comp() const noexcept</code> SpatialMap Returns the function that compares keys in a single dimension <code>dimension_compare dimension_comp() const noexcept;</code> <p>Return value</p> <p>A callable function that compares dimensions, keys, or values.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>These functions return copies of the container's constructor argument <code>comp</code>, or a wrappers around these copies. </p> <p>Example</p> C++ <pre><code>auto fn = pf.dimension_comp();\nif (fn(2.,3.)) {\n    std::cout &lt;&lt; \"2 is less than 3\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"2 is not less than 3\" &lt;&lt; std::endl;\n}\n</code></pre> Output <pre><code>2 is less than 3\n</code></pre>"},{"location":"archive-container/relational-operators/","title":"Relational Operators","text":"<p>These are non-member functions.</p> Method Multimap Compares the values in the multimap <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator==(const archive&lt;K, M, T, C, A&gt; &amp;lhs, const archive&lt;K, M, T, C, A&gt; &amp;rhs);</code> <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator!=(const archive&lt;K, M, T, C, A&gt; &amp;lhs, const archive&lt;K, M, T, C, A&gt; &amp;rhs);</code> FrontContainer Archive-Archive Comparison <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const archive&lt;K, M, T, C&gt; &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs);</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const archive&lt;K, M, T, C&gt; &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const archive&lt;K, M, T, C&gt; &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const archive&lt;K, M, T, C&gt; &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> Archive-Point Comparison <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const archive&lt;K, M, T, C&gt; &amp;lhs, const typename archive&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const archive&lt;K, M, T, C&gt; &amp;lhs, const typename archive&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const archive&lt;K, M, T, C&gt; &amp;lhs, const typename archive&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const archive&lt;K, M, T, C&gt; &amp;lhs, const typename archive&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const typename archive&lt;K, M, T, C&gt;::key_type &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const typename archive&lt;K, M, T, C&gt;::key_type &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const typename archive&lt;K, M, T, C&gt;::key_type &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const typename archive&lt;K, M, T, C&gt;::key_type &amp;lhs, const archive&lt;K, M, T, C&gt; &amp;rhs)</code> <p>Complexity</p> \\[ O(mn) \\] <p>Notes</p> <p>Same notes as SpatialContainer. </p> <p>Example</p> C++ <pre><code>archive&lt;double, 3, unsigned&gt; ar3(ar);\nif (ar == ar3) {\n    std::cout &lt;&lt; \"The archives have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (ar.size() != ar3.size()) {\n        std::cout &lt;&lt; \"The archives do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The archives might not have the same elements\"\n                  &lt;&lt; std::endl;\n    }\n}\n\narchive&lt;double, 3, unsigned&gt; ar4(ar.begin(), ar.end());\nif (ar == ar4) {\n    std::cout &lt;&lt; \"The archives have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (ar.size() != ar4.size()) {\n        std::cout &lt;&lt; \"The archives do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The archives might not have the same elements\"\n                  &lt;&lt; std::endl;\n    }\n}\n\nif (ar_star &lt; ar) {\n    std::cout &lt;&lt; \"ar* dominates ar\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"ar* does not dominate ar\" &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>ar3 = pareto.archive(ar)\nif ar == ar3:\n    print('The containers have the same elements')\nelse:\n    if len(ar) != len(ar3):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n\nar4 = pareto.archive()\nfor [k, v] in ar:\n    ar4[k] = v\n\nif ar == ar4:\n    print('The containers have the same elements')\nelse:\n    if len(ar) != len(ar4):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n\nif ar_star &lt; ar:\n    print('ar* dominates ar')\nelse:\n    print('ar* does not dominate ar')\n</code></pre> Output <pre><code>The archives have the same elements\nThe archives do not have the same elements\nar* dominates ar\n</code></pre>"},{"location":"archive-container/types/","title":"Types","text":"<p>This table summarizes the public types in a <code>pareto::archive&lt;K,M,T,C&gt;</code>:</p> Concept/Type Name Type Notes Container <code>value_type</code> <code>container_type::value_type</code> The pair key is <code>const</code>, like in other associative containers <code>reference</code> <code>value_type&amp;</code> <code>const_reference</code> <code>value_type const &amp;</code> <code>iterator</code> Iterator pointing to a <code>value_type</code> A LegacyBidirectionalIterator convertible to <code>const_iterator</code> <code>const_iterator</code> Iterator pointing to a <code>const value_type</code> Implements LegacyBidirectionalIterator concept <code>difference_type</code> A signed integer <code>size_type</code> An unsigned integer ReversibleContainer <code>reverse_iterator</code> <code>std::reverse_iterator&lt;iterator&gt;</code> <code>const_reverse_iterator</code> <code>std::reverse_iterator&lt;const_iterator&gt;</code> AssociativeContainer <code>key_type</code> <code>pareto::point&lt;K,M&gt;</code> Unlike in <code>value_type</code>, <code>key_type</code>  is not const, so you can use it to construct and manipulate new points <code>mapped_type</code> <code>T</code> <code>key_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>key_compare</code> defines a lexicographic ordering relation over keys using <code>dimension_compare</code> <code>value_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>value_compare</code> defines an ordering relation over <code>value_type</code> using <code>key_compare</code> AllocatorAwareContainer <code>allocator_type</code> <code>container_type::allocator_type</code> <code>allocator_type::value_type</code> is the same as <code>value_type</code> SpatialContainer <code>dimension_type</code> <code>K</code> <code>dimension_compare</code> <code>container_type::dimension_compare</code>, or <code>std::less&lt;K&gt;</code> by default <code>dimension_compare</code> defines an ordering relation over each <code>key_value</code> dimension using <code>C</code> <code>box_type</code> <code>pareto::query_box&lt;dimension_type, M&gt;</code> <code>predicate_list_type</code> <code>pareto::predicate_list&lt;dimension_type, M, T&gt;</code> SpatialAdapter <code>container_type</code> <code>C</code> <code>C</code> needs to follow the SpatialContainer concept ArchiveContainer <code>front_set_type</code> <code>std::set&lt;front_type, std::less&lt;&gt;, front_set_allocator_type&gt;;</code> Set of fronts <p>Notes</p> <p>Note</p> <p>All requirements of fronts also apply here.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>The directory <code>tests/benchmarks</code> include a number of benchmarks we run regularly to infer the performance of our implementations. </p> <p>This section presents the results for each spatial container used with fronts. After building the library, you can replicate these benchmarks locally with:</p> <pre><code>containers_benchmark --benchmark_repetitions=30 --benchmark_display_aggregates_only=true --benchmark_out=containers_benchmark.json --benchmark_out_format=json\n</code></pre> <p>You can later create these plots with the target <code>benchmark_analysis</code> (requires Matplot++).</p> <p>This section presents some benchmarks comparing the following data structures in Pareto fronts: </p> <ul> <li>Implicit Tree</li> <li>Quadtree</li> <li>\\(k\\)d-tree</li> <li>R-tree</li> <li>R*-Tree</li> <li>Boost.Geometry R-Tree</li> </ul> <p>Boost.Geometry</p> <p>We started this library by looking at some alternatives for spatial containers. The alternative that gave us the best results at the time was Boost.Geometry. The header <code>source/pareto/boost_tree.h</code> implements a wrapper on this library that implements a subset of our interface so that we could run these benchmarks. This header is intended for benchmarks only.  </p> <p>Although the basic operations in the Boost.Geometry wrapper have optimal asymptotic complexity, this wrapper is an optional dependency mostly used as a reference for our benchmarks. It takes some workarounds to make this wrapper work as the other containers in this library and it's soon to be deprecated so that this library can move forward. These are a few reasons why we are deprecating Geometry.Boost as a spatial container:</p> <ul> <li>You can't define the dimensions and predicates in runtime, which are important use cases for us</li> <li>Boost.Geometry doesn't completely follow the same C++ named requirements for containers</li> <li>It is not specialized for point trees, so we had better performance with our containers</li> <li>The query iterators are not bidirectional</li> <li>It depends on Boost libraries and functions that are now deprecated</li> </ul>"},{"location":"benchmarks/construct/","title":"Construct","text":""},{"location":"benchmarks/dominance/","title":"Dominance","text":""},{"location":"benchmarks/erase/","title":"Erase","text":""},{"location":"benchmarks/hypervolume-indicator/","title":"Hypervolume indicator","text":"<p>Time</p> <p> </p> <p>Samples vs. Time</p> <p> </p> <p>Samples vs. Gap from the exact hypervolume</p> <p></p>"},{"location":"benchmarks/igd-indicator/","title":"IGD indicator","text":""},{"location":"benchmarks/insert/","title":"Insert","text":""},{"location":"benchmarks/query-intersection/","title":"Query Intersection","text":""},{"location":"benchmarks/query-nearest/","title":"Query Nearest","text":""},{"location":"contributing/contributing-guidelines/","title":"Contributing Guidelines","text":"<p>If contributing with code, please leave these flags ON (<code>-DBUILD_WITH_PEDANTIC_WARNINGS=ON -DBUILD_BOOST_TREE=ON -DBUILD_PYTHON_BINDING=ON</code>), use cppcheck, and clang-format.</p> <p>Example: CLion</p> <p></p>"},{"location":"contributing/contributors/","title":"Contributors","text":"<sub>Jacob</sub> <sub>Alan De Freitas</sub> <sub>Actions-user</sub> <sub>Jonathan Kuck</sub>"},{"location":"contributing/ideas/","title":"Ideas","text":"<p>.</p> <p>If you're looking for an interesting project to contribute, look no more. Here are some cool features that might improve this project and help humanity:</p> <ul> <li>Spatial Containers<ul> <li>Features<ul> <li>Heteregenous keys</li> <li><code>max_dist</code> predicate</li> <li><code>spatial_set</code></li> </ul> </li> <li>Performance<ul> <li>Make <code>erase</code> not invalidate iterators</li> <li>Make use hints</li> <li>Making runtime dimensions competitive with compile-time dimensions</li> <li>Avoid unnecessary copies in general</li> <li>Keep vectors sorted when \\(m &lt; 3\\)</li> </ul> </li> <li>Code quality<ul> <li>Remove redundancies in container code</li> <li>Avoid copies in insertion and removal algorithms </li> <li>Implement <code>comp_</code> for predicates and unit tests</li> <li>Deprecate <code>find_*</code> in favour of <code>find(predicate_list)</code> only</li> <li>Implement node handles <code>node_type</code></li> </ul> </li> </ul> </li> <li>Front Container<ul> <li>More indicators</li> <li>Special dominance relationships like \\(\\epsilon\\)-dominance and cone-\\(\\epsilon\\)-dominance</li> </ul> </li> <li>Archives Container<ul> <li>Improve performance of archive queries</li> <li>Let archive iterators move logically to next fronts</li> </ul> </li> <li>Python bindings<ul> <li>Replicate Matplot++ examples with Matplotlib</li> <li>Integrate scikit-build <sup>[ 1, 2, 3 ]</sup></li> </ul> </li> <li>Examples<ul> <li>Adjust the Matplot++ examples to receive <code>axes_handle</code> as parameter</li> <li>More interesting examples</li> </ul> </li> </ul> <p>Contributions in which we are not interested:</p> <ul> <li>\"I don't like this optional feature so I removed/deprecated it\"</li> <li>\"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative</li> <li>\"I removed this feature so I don't have to update CMake\" but have not provided an equivalent alternative</li> <li>\"I'm creating this high-cost promise that we'll support __ forever\" but I'm not sticking around</li> <li>In doubt, please open a discussion first</li> </ul>"},{"location":"contributing/thanks/","title":"Thanks","text":"<p>We would like to thank the developers of these libraries:</p> <ul> <li>hv-2.0rc2/hv.h for calculating hyper-volumes: we adapted this implementation as a reference for our hypervolume algorithm</li> <li>Boost.Geometry package: we use Boost.Geometry for our benchmarks</li> <li>Spatial C++ Library: our second reference besides Boost.Geometry</li> </ul>"},{"location":"front-container/allocators/","title":"Allocators","text":"Method AllocatorAwareContainer <code>allocator_type get_allocator() const noexcept;</code> <p>Return value</p> <p>The associated allocator.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>This function returns the allocator of the underlying container. </p> <p>Info</p> <p>See the section on spatial map allocators for more information.</p> <p>Example</p> C++ <pre><code>#include &lt;pareto/front.h&gt;\n// ...\npareto::front&lt;double, 3, unsigned&gt; pf;\n// Get a copy of the container allocator\nauto alloc = pf.get_allocator();\n</code></pre>"},{"location":"front-container/capacity-and-reference-points/","title":"Capacity and Reference Points","text":"Method MultimapContainer Check size <code>[[nodiscard]] bool empty() const noexcept;</code> <code>[[nodiscard]] size_type size() const noexcept;</code> <code>[[nodiscard]] size_type max_size() const noexcept;</code> SpatialContainer Check dimensions <code>[[nodiscard]] size_type dimensions() const noexcept;</code> Get max/min values <code>dimension_type max_value(size_type dimension) const;</code> <code>dimension_type min_value(size_type dimension) const;</code> FrontContainer Reference points <code>key_type ideal() const;</code> <code>dimension_type ideal(size_type dimension) const;</code> <code>key_type nadir() const;</code> <code>dimension_type nadir(size_type dimension) const;</code> <code>key_type worst() const;</code> <code>dimension_type worst(size_type dimension) const;</code> Target directions <code>[[nodiscard]] bool is_minimization() const noexcept</code> <code>[[nodiscard]] bool is_maximization() const noexcept</code> <code>[[nodiscard]] bool is_minimization(size_t dimension) const noexcept</code> <code>[[nodiscard]] bool is_maximization(size_t dimension) const noexcept</code> <p>Parameters</p> <ul> <li><code>dimension</code> - index of the dimension for which we want the minimum or maximum value</li> </ul> <p>Return value</p> <ul> <li><code>empty()</code>- <code>true</code> if and only if container (equivalent but more efficient than <code>begin() == end()</code>)</li> <li><code>size()</code> - The number of elements in the container</li> <li><code>max_size()</code> - An upper bound on the maximum number of elements the container can hold</li> <li><code>dimensions()</code> - Number of dimensions in the container (same as <code>M</code>, when <code>M != 0</code>)</li> <li><code>max_value(d)</code> - Maximum value in a given dimension <code>d</code></li> <li><code>min_value(d)</code> - Minimum value in a given dimension <code>d</code></li> <li><code>ideal()</code> - Key with best value possible in each dimension</li> <li><code>ideal(d)</code> - Best value possible in a given dimension <code>d</code></li> <li><code>nadir()</code> - Key with worst value possible in each dimension</li> <li><code>nadir(d)</code> - Worst value possible in a given dimension <code>d</code></li> <li><code>worst()</code> - Key with worst value possible in each dimension</li> <li><code>worst(d)</code> - Worst value possible in a given dimension <code>d</code></li> <li><code>is_minimization()</code>, <code>is_maximization()</code>: true if and only if all directions are minimization / maximization</li> <li><code>is_minimization(i)</code>, <code>is_maximization(i)</code>: true if and only if dimension <code>i</code> is minimization / maximization</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>Because all container nodes keep their minimum bounding rectangles, we can find these values in constant time. These reference points are important components of other queries and indicators for fronts, so it's useful to obtain these values in constant time. </p> <p>The nadir point</p> <p>Although <code>nadir</code> and <code>worst</code> return the same values for fronts, they are semantically different and, do not return the same values for archives. The nadir point refers to the worst objective values over the efficient set of values in a multiobjective optimization problem, while the worst point simply refers to the worst values in a container.</p> <p>The nadir point approximation is usually obtained by iteratively optimizing a problem as \\(m\\) uni-dimensional problems. The best estimate of the nadir point happens to be the worst point here because the front container doesn't have enough information about the underlying problem. This, however, is not the case for the archive container, which is the reason why we keep this distinction here.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>if (pf.empty()) {\n    std::cout &lt;&lt; \"Front is empty\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"Front is not empty\" &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; pf.size() &lt;&lt; \" elements in the front\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; pf.dimensions() &lt;&lt; \" dimensions\" &lt;&lt; std::endl;\nfor (size_t i = 0; i &lt; pf.dimensions(); ++i) {\n    if (pf.is_minimization(i)) {\n        std::cout &lt;&lt; \"Dimension \" &lt;&lt; i &lt;&lt; \" is minimization\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Dimension \" &lt;&lt; i &lt;&lt; \" is maximization\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"Best value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.ideal(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Min value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.min_value(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Max value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.max_value(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Best value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.ideal(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Nadir value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.nadir(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Worst value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.worst(i) &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; \"Ideal point: \" &lt;&lt; pf.ideal() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Nadir point: \" &lt;&lt; pf.nadir() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Worst point: \" &lt;&lt; pf.worst() &lt;&lt; std::endl;\n</code></pre> Python <pre><code>if pf:\n    print('Front is not empty')\nelse:\n    print('Front is empty')\n\nprint(len(pf), 'elements in the front')\nprint(pf.dimensions(), 'dimensions')\nfor i in range(pf.dimensions()):\n    if pf.is_minimization(i):\n        print('Dimension', i, ' is minimization')\n    else:\n        print('Dimension', i, ' is maximization')\n    print('Best value in dimension', i, ':', pf.ideal(i))\n    print('Min value in dimension', i, ':', pf.min_value(i))\n    print('Max value in dimension', i, ':', pf.max_value(i))\n    print('Best value in dimension', i, ':', pf.ideal(i))\n    print('Nadir value in dimension', i, ':', pf.nadir(i))\n    print('Worst value in dimension', i, ':', pf.worst(i))\n\nprint('Ideal point:', pf.ideal())\nprint('Nadir point:', pf.nadir())\nprint('Worst point:', pf.worst())\n</code></pre> Output <pre><code>Front is not empty\n20 elements in the front\n3 dimensions\nDimension 0 is minimization\nBest value in dimension 0: -2.57664\nMin value in dimension 0: -2.57664\nMax value in dimension 0: 1.49101\nBest value in dimension 0: -2.57664\nNadir value in dimension 0: 1.49101\nWorst value in dimension 0: 1.49101\nDimension 1 is maximization\nBest value in dimension 1: 3.24052\nMin value in dimension 1: -1.52034\nMax value in dimension 1: 3.24052\nBest value in dimension 1: 3.24052\nNadir value in dimension 1: -1.52034\nWorst value in dimension 1: -1.52034\nDimension 2 is minimization\nBest value in dimension 2: -2.92346\nMin value in dimension 2: -2.92346\nMax value in dimension 2: 2.78224\nBest value in dimension 2: -2.92346\nNadir value in dimension 2: 2.78224\nWorst value in dimension 2: 2.78224\nIdeal point: [-2.57664, 3.24052, -2.92346]\nNadir point: [1.49101, -1.52034, 2.78224]\nWorst point: [1.49101, -1.52034, 2.78224]\n</code></pre>"},{"location":"front-container/constructors/","title":"Constructors","text":"Method Container + AllocatorAwareContainer Constructors <code>explicit front(const allocator_type &amp;alloc = allocator_type())</code> <code>front(const front &amp;rhs)</code> <code>front(const front &amp;rhs, const allocator_type &amp;alloc)</code> <code>front(front &amp;&amp;rhs) noexcept</code> <code>front(front &amp;&amp;rhs, const allocator_type &amp;alloc) noexcept</code> AssociativeContainer + AllocatorAwareContainer Constructors <code>explicit front(const C &amp;comp, const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; front(InputIt first, InputIt last, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>front(std::initializer_list&lt;value_type&gt; il, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; front(InputIt first, InputIt last, const allocator_type &amp;alloc)</code> <code>front(std::initializer_list&lt;value_type&gt; il, const allocator_type &amp;alloc)</code> FrontContainer <code>template &lt;class InputIt, class DirectionIt&gt; front(InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir,       const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class DirectionIt&gt; front(std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt&gt; front(InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>front(std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(),       const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>front(std::initializer_list&lt;bool&gt; il_dir, const dimension_compare &amp;comp = dimension_compare(), const allocator_type &amp;alloc = construct_allocator&lt;allocator_type&gt;())</code> <code>template &lt;class InputIt, class DirectionIt&gt; front(InputIt first, InputIt last, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class DirectionIt&gt; front(std::initializer_list&lt;value_type&gt; il, DirectionIt first_dir, DirectionIt last_dir, const allocator_type &amp;alloc)</code> <code>template &lt;class InputIt&gt; front(InputIt first, InputIt last, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>front(std::initializer_list&lt;value_type&gt; il, std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> <code>front(std::initializer_list&lt;bool&gt; il_dir, const allocator_type &amp;alloc)</code> AssociativeContainer + AllocatorAwareContainer Assignment <code>front &amp;operator=(const front &amp;rhs)</code> <code>front &amp;operator=(front &amp;&amp;rhs) noexcept</code> AssociativeContainer Assignment <code>front &amp;operator=(std::initializer_list&lt;value_type&gt; il) noexcept</code> <p>Parameters</p> Parameter Description <code>alloc</code> allocator to use for all memory allocations of this container <code>comp</code> comparison function object to use for all comparisons of keys <code>first</code>, <code>last</code> the range to copy the elements from <code>rhs</code> another container to be used as source to initialize the elements of the container with <code>il</code> initializer list to initialize the elements of the container with <code>first_dir</code>, <code>last_dir</code> the range to copy the target directions from <code>il_dir</code> initializer list to initialize the target directions of the container with <p>Requirements</p> Type requirements -<code>InputIt</code> and <code>DirectionIt</code> must meet the requirements of LegacyInputIterator. -<code>Compare</code> must meet the requirements of Compare. -<code>Allocator</code> must meet the requirements of Allocator. <p>Complexity</p> Method Complexity Empty constructor \\(O(1)\\) Copy constructor \\(O(mn)\\) Move constructor \\(O(1)\\) if <code>get_allocator() == rhs.get_allocator()</code> Construct from range, or assignment \\(O(m n \\log n)\\) <p>Notes</p> <p>All constructors in FrontContainer replicate the constructors for spatial containers with an extra parameter to provide target directions (minimization / maximization). If the dimensions are not supposed to be minimized, we can define one optimization direction for each dimension. </p> <p>Default directions</p> <p>By default, all directions are minimized. Whenever we insert an element in a front, it erases all elements dominated by the new solution:</p> <p></p> <p>Varying directions</p> <p>If we set all directions to <code>maximization</code>, this is what a 2-dimensional front looks like:</p> <p></p> <p>And these are the combinations for two-dimensional fronts:</p> <p></p> <p>In more than two dimensions, we usually represent fronts with parallel coordinates:</p> <p></p> <p>Plotting fronts</p> <p>The header <code>pareto/matplot/front.h</code> contains an example of a function to plot fronts with Matplot++. The file <code>examples/matplotpp_example.cpp</code> includes an example that uses these plot functions. In Python, you can use Matplotlib like you would with any other linear list of points.</p> <p>Example</p> C++ <pre><code>#include &lt;pareto/front.h&gt;\n#include &lt;pareto/kd_tree.h&gt;\n// ...\n// Constructing the default front\nfront&lt;double, 3, unsigned&gt; pf({min, max, min});\n// Constructing a front based on kd trees\nfront&lt;double, 3, unsigned, kd_tree&lt;double, 3, unsigned&gt;&gt; pf2({min, max, min});\n</code></pre> Python <pre><code>import pareto\n# ...\n# Constructing the default front\npf = pareto.front(['min', 'max', 'min']);\n# Constructing a front based on kd trees\npf2 = pareto.kd_front(['min', 'max', 'min']);\n</code></pre>"},{"location":"front-container/dominance-relationships/","title":"Dominance Relationships","text":"Method FrontContainer Front-Point Dominance <code>bool dominates(const key_type &amp;p)</code> <code>bool strongly_dominates(const key_type &amp;p) const</code> <code>bool is_partially_dominated_by(const key_type &amp;p) const</code> <code>bool is_completely_dominated_by(const key_type &amp;p) const</code> <code>bool non_dominates(const key_type &amp;p) const</code> Front-Front Dominance <code>bool dominates(const front &amp;P) const</code> <code>bool strongly_dominates(const front &amp;P) const</code> <code>bool is_partially_dominated_by(const front &amp;P) const</code> <code>bool is_completely_dominated_by(const front &amp;P) const</code> <code>bool non_dominates(const front &amp;P) const</code> <p>Parameters</p> <ul> <li><code>p</code> - point we are checking for dominance</li> <li><code>P</code> - front we are checking for dominance</li> </ul> <p>Return value</p> <ul> <li><code>bool</code>- <code>true</code> if and only if the point <code>p</code> or front <code>P</code> is dominated, is strongly dominated, partially dominates, completely dominates, or non-dominates <code>*this</code></li> </ul> <p>Complexity</p> <ul> <li><code>is_completely_dominated_by</code>:  \\(O(1)\\) for points and \\(O(n)\\) for fronts</li> <li>All others:  \\(O(m \\log n)\\) for points and \\(O(m n \\log n)\\) for fronts</li> </ul> <p>Notes</p> <p>A solution \\(x_1\\) (weakly) dominates \\(x_2\\)  (denoted \\(x_1 \\prec x_2\\)) if \\(x_1\\) is 1) better than \\(x_2\\) in at least one dimension and 2) not worse than \\(x_2\\) in any dimension:</p> <p>Point-point dominance</p> <p></p> <p>The <code>pareto::point</code> object contains function to check dominance between points without depending on the front. </p> <p>We can also check for dominance between fronts and points (denoted \\(p \\prec P\\) or \\(P \\prec p\\)). This is a fundamental component of the insertion and removal algorithms.</p> <p>Front-point dominance</p> <p></p> <p>Non-dominance</p> <p>Saying \\(p\\) non-dominates \\(P\\) is different from saying \\(p\\) does not dominate \\(P\\). The first means \\(p\\) and \\(P\\) are incomparable, the second means \\(p\\) and \\(P\\) are either incomparable or \\(p\\) dominates \\(P\\).</p> <p>At last, we can check dominance relationships between fronts. The dominance relationships between front \\(P_1\\) and front \\(P_2\\) (denoted \\(P_1 \\prec P_2\\)) is defined when all points in \\(P_1\\) are dominated by some point in \\(P_2\\). This establishes an order relationship which is a chief component of the archive data structure.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>// Point-point dominance\nusing point_type = front&lt;double, 3, unsigned&gt;::key_type;\npoint_type p1({0, 0, 0});\npoint_type p2({1, 1, 1});\nstd::vector&lt;bool&gt; is_minimization = {true, false, true};\nstd::cout &lt;&lt; (p1.dominates(p2, is_minimization) ? \"p1 dominates p2\" : \"p1 does not dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (p1.strongly_dominates(p2, is_minimization) ? \"p1 strongly dominates p2\" : \"p1 does not strongly dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (p1.non_dominates(p2, is_minimization) ? \"p1 non-dominates p2\" : \"p1 does not non-dominate p2\") &lt;&lt; std::endl;\n\n// Front-point dominance\nstd::cout &lt;&lt; (pf.dominates(p2) ? \"pf dominates p2\" : \"pf does not dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.strongly_dominates(p2) ? \"pf strongly dominates p2\" : \"pf does not strongly dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.non_dominates(p2) ? \"pf non-dominates p2\" : \"pf does not non-dominate p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.is_partially_dominated_by(p2) ? \"pf is partially dominated by p2\" : \"pf is not is partially dominated by p2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.is_completely_dominated_by(p2) ? \"pf is completely dominated by p2\" : \"pf is not is completely dominated by p2\") &lt;&lt; std::endl;\n\n// Front-front dominance\nfront&lt;double, 3, unsigned&gt; pf2({min, max, min});\nfor (const auto&amp; [p,v]: pf) {\n    pf2[point_type({p[0] - 1, p[1] + 1, p[2] - 1})] = v;\n}\nstd::cout &lt;&lt; (pf.dominates(pf2) ? \"pf dominates pf2\" : \"pf does not dominate pf2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.strongly_dominates(pf2) ? \"pf strongly dominates pf2\" : \"pf does not strongly dominate pf2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.non_dominates(pf2) ? \"pf non-dominates pf2\" : \"pf does not non-dominate pf2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.is_partially_dominated_by(pf2) ? \"pf is partially dominated by pf2\" : \"pf is not is partially dominated by pf2\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; (pf.is_completely_dominated_by(pf2) ? \"pf is completely dominated by pf2\" : \"pf is not is completely dominated by pf2\") &lt;&lt; std::endl;\n</code></pre> Python <pre><code># Point-point dominance\np1 = pareto.point([0, 0, 0])\np2 = pareto.point([1, 1, 1])\nis_minimization = [True, False, True]\nprint('p1 dominates p2' if p1.dominates(p2, is_minimization) else 'p1 does not dominate p2')\nprint('p1 strongly dominates p2' if p1.strongly_dominates(p2, is_minimization) else 'p1 does not strongly dominate p2')\nprint('p1 non-dominates p2' if p1.non_dominates(p2, is_minimization) else 'p1 does not non-dominate p2')\n\n# Front-point dominance\nprint('pf dominates p2' if pf.dominates(p2) else 'pf does not dominate p2')\nprint('pf strongly dominates p2' if pf.strongly_dominates(p2) else 'pf does not strongly dominate p2')\nprint('pf non-dominates p2' if pf.non_dominates(p2) else 'pf does not non-dominate p2')\nprint('pf is partially dominated by p2' if pf.is_partially_dominated_by(p2) else 'pf is not is partially dominated by p2')\nprint('pf is completely dominated by p2' if pf.is_completely_dominated_by(p2) else 'pf is not is completely dominated by p2')\n\n# Front-front dominance\npf2 = pareto.front(['min', 'max', 'min'])\nfor [p, v] in pf:\n    pf2[pareto.point([p[0] - 1, p[1] + 1, p[2] - 1])] = v\n\nprint('pf dominates pf2' if pf.dominates(pf2) else 'pf does not dominate pf2')\nprint('pf strongly dominates pf2' if pf.strongly_dominates(pf2) else 'pf does not strongly dominate pf2')\nprint('pf non-dominates pf2' if pf.non_dominates(pf2) else 'pf does not non-dominate pf2')\nprint('pf is partially dominated by pf2' if pf.is_partially_dominated_by(pf2) else 'pf is not is partially dominated by pf2')\nprint('pf is completely dominated by pf2' if pf.is_completely_dominated_by(pf2) else 'pf is not is completely dominated by pf2')\n</code></pre> Output <pre><code>p1 does not dominate p2\np1 does not strongly dominate p2\np1 non-dominates p2\npf dominates p2\npf strongly dominates p2\npf does not non-dominate p2\npf is not is partially dominated by p2\npf is not is completely dominated by p2\npf does not dominate pf2\npf does not strongly dominate pf2\npf does not non-dominate pf2\npf is partially dominated by pf2\npf is completely dominated by pf2\n</code></pre>"},{"location":"front-container/element-access/","title":"Element Access","text":"Method MapContainer Access and throw exception if it doesn't exist <code>mapped_type &amp;at(const key_type &amp;k);</code> <code>const mapped_type &amp;at(const key_type &amp;k) const;</code> Access and create new element if it doesn't exist <code>mapped_type &amp;operator[] (const key_type &amp;k);</code> <code>mapped_type &amp;operator[] (key_type &amp;&amp;k);</code> <code>template &lt;typename... Targs&gt; mapped_type &amp;operator()(const dimension_type &amp;x1, const Targs &amp;...xs);</code> <p>Parameters</p> <ul> <li><code>k</code> - the key of the element to find</li> <li><code>x1</code> - the value of the element to find in the first dimension</li> <li><code>xs</code> - the value of the element to find in other dimensions</li> </ul> <p>Return value</p> <p>A reference to the element associated with that key.</p> <p>Exceptions</p> <p><code>std::out_of_range</code> if the container does not have an element with the specified <code>key</code></p> <p>Complexity</p> \\[ O(m \\log n) \\] <p>Notes</p> <p>Unlike in a <code>pareto::spatial_map</code>, the <code>insert</code> operation for fronts is allowed to fail when the new element is already dominated by the front. In this case, the <code>operator[]</code> will return a reference to a placeholder that is not ultimately inserted in the front.</p> <p>Info</p> <p>See the section on spatial containers / element access for more information.</p> <p>Example</p> C++ <pre><code>front&lt;double, 3, unsigned&gt; pf({min, max, min});\n// Set some values\npf(-2.57664, -1.52034, 0.600798) = 17;\npf(-2.14255, -0.518684, -2.92346) = 32;\npf(-1.63295, 0.912108, -2.12953) = 36;\npf(-0.653036, 0.927688, -0.813932) = 13;\npf(-0.508188, 0.871096, -2.25287) = 32;\npf(-2.55905, -0.271349, 0.898137) = 6;\npf(-2.31613, -0.219302, 0) = 8;\npf(-0.639149, 1.89515, 0.858653) = 10;\npf(-0.401531, 2.30172, 0.58125) = 39;\npf(0.0728106, 1.91877, 0.399664) = 25;\npf(-1.09756, 1.33135, 0.569513) = 20;\npf(-0.894115, 1.01387, 0.462008) = 11;\npf(-1.45049, 1.35763, 0.606019) = 17;\npf(0.152711, 1.99514, -0.112665) = 13;\npf(-2.3912, 0.395611, 2.78224) = 11;\npf(-0.00292544, 1.29632, -0.578346) = 20;\npf(0.157424, 2.30954, -1.23614) = 6;\npf(0.453686, 1.02632, -2.24833) = 30;\npf(0.693712, 1.12267, -1.37375) = 12;\npf(1.49101, 3.24052, 0.724771) = 24;\n\n// Access value\nif (pf.contains({1.49101, 3.24052, 0.724771})) {\n    std::cout &lt;&lt; \"Element access: \" &lt;&lt; pf(1.49101, 3.24052, 0.724771) &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"{1.49101, 3.24052, 0.724771} was dominated\" &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>pf = pareto.front()\n# Set some values\npf[-2.57664, -1.52034, 0.600798] = 17\npf[-2.14255, -0.518684, -2.92346] = 32\npf[-1.63295, 0.912108, -2.12953] = 36\npf[-0.653036, 0.927688, -0.813932] = 13\npf[-0.508188, 0.871096, -2.25287] = 32\npf[-2.55905, -0.271349, 0.898137] = 6\npf[-2.31613, -0.219302, 0] = 8\npf[-0.639149, 1.89515, 0.858653] = 10\npf[-0.401531, 2.30172, 0.58125] = 39\npf[0.0728106, 1.91877, 0.399664] = 25\npf[-1.09756, 1.33135, 0.569513] = 20\npf[-0.894115, 1.01387, 0.462008] = 11\npf[-1.45049, 1.35763, 0.606019] = 17\npf[0.152711, 1.99514, -0.112665] = 13\npf[-2.3912, 0.395611, 2.78224] = 11\npf[-0.00292544, 1.29632, -0.578346] = 20\npf[0.157424, 2.30954, -1.23614] = 6\npf[0.453686, 1.02632, -2.24833] = 30\npf[0.693712, 1.12267, -1.37375] = 12\npf[1.49101, 3.24052, 0.724771] = 24\n\n# Access value\nif [1.49101, 3.24052, 0.724771] in pf:\n    print('Element access:', pf[1.49101, 3.24052, 0.724771])\nelse:\n    print(\"[1.49101, 3.24052, 0.724771] was dominated\")\n</code></pre> Output <pre><code>Element access: 24\n</code></pre>"},{"location":"front-container/front-concept/","title":"Front Concept","text":"<p>Most lifelike problems involve several conflicting goals. For this reason, the concepts of Pareto fronts and archives have applications that range from economics to engineering. In Game Theory, we have these kinds of outcomes:</p> Outcome Description Pareto efficient or Pareto optimal No other outcome can increase the utility in one goal without decreasing the utility of any other goal Pareto inefficient There is another that can improve at least one goal without harming other goals Pareto improvement over \\(p\\) Better than the Pareto inefficient outcome \\(p\\) Pareto dominated by \\(p\\) Outcome \\(p\\) can improve at least one goal without harming other goals Pareto dominated by \\(p\\) Outcome \\(p\\) can improve at least one goal without harming other goals <p>Although many outcomes can be Pareto optimal, no outcome dominates an outcome that is Pareto optimal. The set of all Pareto optimal outcomes is the Pareto front (also Pareto frontier, or Pareto set).</p> <p>Example: Pareto front</p> <p>This is a two-dimensional Pareto front. The region in gray is dominated by the front.</p> <p></p> <p>In this example, we consider lower values of \\(f(x)\\) to be a gain of utility</p> <p>Formal Definition: Pareto front</p> <p>The set \\(P\\) of all Pareto optimal outcomes, is defined as</p> \\[ P = \\{\\; x \\;|\\; \\tilde \\exists y\\; \\exists i\\; (f_i(y) &lt; f_i(x)) \\;\\} = \\{\\; x \\;|\\; \\tilde \\exists y\\; (y \\prec x)\\} \\] <p>where \\(f_i(x)\\) is the \\(i\\)-th goal in our problem</p> <p>Every game has at least one outcome that is Pareto optimal.</p> <p>The container <code>pareto::front</code> is an extension and an adapter of spatial containers for Pareto fronts. The container uses query predicates to find and erase any dominated solution whenever a new solution is inserted.</p>"},{"location":"front-container/iterators/","title":"Iterators","text":"Method MultimapContainer Get constant iterators <code>const_iterator begin() const noexcept;</code> <code>const_iterator end() const noexcept;</code> <code>const_iterator cbegin() const noexcept;</code> <code>const_iterator cend() const noexcept;</code> Get iterators <code>iterator begin() noexcept;</code> <code>iterator end() noexcept;</code> Get reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; rbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; rend() const noexcept;</code> <code>std::reverse_iterator&lt;iterator&gt; rbegin() noexcept</code>; <code>std::reverse_iterator&lt;iterator&gt; rend() noexcept;</code> Get constant reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; crbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; crend() const noexcept;</code> <p>Return value</p> <ul> <li><code>begin()</code> - Iterator to the first element in the container</li> <li><code>end()</code> - Iterator to the past-the-end element in the container (see notes)</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>All requirements of a SpatialContainer also apply here.</p> <p>Info</p> <p>See the section on spatial containers / iterators for more information.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>std::cout &lt;&lt; \"Iterators:\" &lt;&lt; std::endl;\nfor (const auto&amp; [point, value]: pf) {\n    std::cout &lt;&lt; point &lt;&lt; \" -&gt; \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\nstd::cout &lt;&lt; \"Reversed Iterators:\" &lt;&lt; std::endl;\nfor (auto it = pf.rbegin(); it != pf.rend(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>print('Iterators')\nfor [point, value] in m:\n    print(point, '-&gt;', value)\n\nprint('Reversed Iterators')\nfor [point, value] in reversed(m):\n    print(point, '-&gt;', value)\n</code></pre> Output <pre><code>Iterators:\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[1.49101, 3.24052, 0.724771] -&gt; 24\nReversed Iterators:\n[1.49101, 3.24052, 0.724771] -&gt; 24\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.31613, -0.219302, 0] -&gt; 8\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n</code></pre>"},{"location":"front-container/lookup-and-queries/","title":"Lookup and Queries","text":"Method Multimap Returns the number of elements matching specific key <code>size_type count(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; size_type count(const L &amp;p) const</code> Finds element with specific key <code>iterator find(const key_type &amp;p);</code> <code>const_iterator find(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; iterator find(const L &amp;p)</code> <code>template &lt;class L&gt; const_iterator find(const L &amp;p) const;</code> Checks if the container contains element with specific key <code>bool contains(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; bool contains(const L &amp;p) const;</code> SpatialContainer Get iterator to first element that passes the predicates <code>const_iterator find(const predicate_list_type &amp;ps) const noexcept;</code> <code>iterator find(const predicate_list_type &amp;ps) noexcept;</code> Find intersection between point and container <code>iterator find_intersection(const key_type &amp;p);</code> <code>const_iterator find_intersection(const key_type &amp;p) const;</code> Find intersection between container and query box <code>iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find points inside a query box (excluding borders) <code>iterator find_within(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_within(const key_type &amp;lb, const key_type &amp;ub) const</code> Find points outside a query box <code>iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find the elements closest to a point <code>iterator find_nearest(const key_type &amp;p);</code> <code>const_iterator find_nearest(const key_type &amp;p) const;</code> <code>iterator find_nearest(const key_type &amp;p, size_t k);</code> <code>const_iterator find_nearest(const key_type &amp;p, size_t k) const;</code> <code>iterator find_nearest(const box_type &amp;b, size_t k);</code> <code>const_iterator find_nearest(const box_type &amp;b, size_t k) const;</code> Find min/max elements <code>iterator max_element(size_t dimension)</code> <code>const_iterator max_element(size_t dimension) const</code> <code>iterator min_element(size_t dimension)</code> <code>const_iterator min_element(size_t dimension) const</code> FrontContainer Find sets of dominated elements <code>const_iterator find_dominated(const key_type &amp;p) const</code> <code>iterator find_dominated(const key_type &amp;p)</code> Find nearest point excluding \\(p\\) <code>const_iterator find_nearest_exclusive(const key_type &amp;p) const</code> <code>iterator find_nearest_exclusive(const key_type &amp;p)</code> Find extreme elements <code>const_iterator ideal_element(size_t d) const</code> <code>iterator ideal_element(size_t d)</code> <code>const_iterator nadir_element(size_t d) const</code> <code>iterator nadir_element(size_t d)</code> <code>const_iterator worst_element(size_t d) const</code> <code>iterator worst_element(size_t d)</code> <p>Parameters</p> <ul> <li><code>ps</code> - a list of predicates</li> <li><code>p</code> - a point of type <code>key_value</code> or convertible to <code>key_value</code></li> <li><code>lb</code> and <code>ub</code> - lower and upper bounds of the query box</li> <li><code>k</code> - number of nearest elements</li> </ul> <p>Return value</p> <ul> <li><code>count()</code>: <code>size_type</code>: number of elements with a given key</li> <li><code>container()</code>: <code>bool</code>: <code>true</code> if and only if the container contains an element with the given key <code>p</code></li> <li><code>find_*</code>: <code>iterator</code> and <code>const_iterator</code> - Iterator to the first element that passes the query predicates</li> <li><code>find</code> returns a normal iterator</li> <li>all other <code>find_*</code> functions return a query iterator (see below)</li> <li><code>size_type</code> - Number of elements erased</li> </ul> <p>Complexity</p> \\[ O(m \\log n) \\] <p>Notes</p> <p>The front concept contains two extra functions for queries:</p> <ul> <li><code>find_dominated</code> find all points in a front dominated by <code>p</code></li> <li><code>find_nearest_exclusive</code> finds the point closest to <code>p</code>, excluding <code>p</code> itself from the query</li> </ul> <p>Info</p> <p>All other definitions and requirements of a SpatialContainer also apply here.</p> <p>It also contains functions to find the best and worst elements in a given dimension.</p> <p>Examples</p> <p>Continuing from the previous example:</p> C++ <pre><code>for (auto it = pf.find_intersection(pf.ideal(), {-2.3912, 0.395611, 2.78224}); it != pf.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = pf.find_within(pf.ideal(), {-2.3912, 0.395611, 2.78224}); it != pf.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = pf.find_disjoint(pf.worst(), {+0.71, +1.19, +0.98}); it != pf.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = pf.find_nearest({-2.3912, 0.395611, 2.78224}, 2); it != pf.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nauto it_near = pf.find_nearest({2.5, 2.5, 2.5});\nstd::cout &lt;&lt; it_near-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it_near-&gt;second &lt;&lt; std::endl;\nfor (auto it = pf.find_dominated({-10, +10, -10}); it != pf.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (size_t i = 0; i &lt; pf.dimensions(); ++i) {\n    std::cout &lt;&lt; \"Ideal element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.ideal_element(i)-&gt;first &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Nadir element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.nadir_element(i)-&gt;first &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Worst element in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pf.worst_element(i)-&gt;first &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>for [k, v] in pf.find_intersection(pf.ideal(), pareto.point([-2.3912, 0.395611, 2.78224])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in pf.find_within(pf.ideal(), pareto.point([-2.3912, 0.395611, 2.78224])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in pf.find_disjoint(pf.worst(), pareto.point([+0.71, +1.19, +0.98])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in pf.find_nearest(pareto.point([-2.3912, 0.395611, 2.78224]), 2):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in pf.find_nearest(pareto.point([2.5, 2.5, 2.5])):\n    print(k, \"-&gt;\", v)\n\nfor [k, v] in pf.find_dominated(pareto.point([-10, +10, -10])):\n    print(k, \"-&gt;\", v)\n\nfor i in range(pf.dimensions()):\n    print('Ideal element in dimension', i, ': ', pf.ideal_element(i)[0])\n    print('Nadir element in dimension', i, ': ', pf.nadir_element(i)[0])\n    print('Worst element in dimension', i, ': ', pf.worst_element(i)[0])\n</code></pre> Output <pre><code>[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\nIdeal element in dimension 0: [-2.57664, -1.52034, 0.600798]\nNadir element in dimension 0: [0.693712, 1.12267, -1.37375]\nWorst element in dimension 0: [0.693712, 1.12267, -1.37375]\nIdeal element in dimension 1: [0.157424, 2.30954, -1.23614]\nNadir element in dimension 1: [-2.57664, -1.52034, 0.600798]\nWorst element in dimension 1: [-2.57664, -1.52034, 0.600798]\nIdeal element in dimension 2: [-2.14255, -0.518684, -2.92346]\nNadir element in dimension 2: [-2.3912, 0.395611, 2.78224]\nWorst element in dimension 2: [-2.3912, 0.395611, 2.78224]\n</code></pre>"},{"location":"front-container/modifiers/","title":"Modifiers","text":"Method Container + AllocatorAwareContainer Exchanges the contents of the container with those of <code>rhs</code> <code>void swap(kd_tree &amp;rhs) noexcept;</code> Multimap Erases all elements from the container <code>void clear();</code> Inserts element(s) into the container <code>iterator insert(const value_type &amp;v);</code> <code>iterator insert(value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(P &amp;&amp;v);</code> <code>iterator insert(iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(const_iterator hint, P &amp;&amp;v);</code> <code>template &lt;class Inputiterator&gt; void insert(Inputiterator first, Inputiterator last);</code> <code>void insert(std::initializer_list&lt;value_type&gt; init);</code> Inserts a new element into the container constructed in-place with the given <code>args</code> <code>template &lt;class... Args&gt; iterator emplace(Args &amp;&amp;...args);</code> <code>template &lt;class... Args&gt; iterator emplace_hint(const_iterator, Args &amp;&amp;...args);</code> Removes specified elements from the container <code>iterator erase(const_iterator position);</code> <code>iterator erase(iterator position);</code> <code>iterator erase(const_iterator first, const_iterator last);</code> <code>size_type erase(const key_type &amp;k);</code> Attempts to extract (\"splice\") each element in <code>source</code> and insert it into <code>*this</code> <code>void merge(front &amp;source) noexcept;</code> <code>void merge(front &amp;&amp;source) noexcept;</code> <p>Parameters</p> <ul> <li><code>rhs</code> - container to exchange the contents with</li> <li><code>v</code> - element value to insert</li> <li><code>first</code>, <code>last</code> - range of elements to insert/erase</li> <li><code>init</code> - initializer list to insert the values from</li> <li><code>hint</code> - iterator, used as a suggestion as to where to start the search</li> <li><code>position</code> - iterator pointer to element to erase</li> <li><code>k</code> - key value of the elements to remove</li> <li><code>source</code> - container to get elements from</li> </ul> <p>Return value</p> <ul> <li><code>iterator</code> - Iterator to the new element (<code>insert</code>) or following the last removed element (<code>erase</code>)</li> <li><code>size_type</code> - Number of elements erased</li> </ul> <p>Complexity</p> <ul> <li><code>insert</code>, <code>emplace</code>,  <code>erase</code>: \\(O(m \\log n)\\)</li> <li><code>swap</code>: \\(O(1)\\)</li> <li><code>merge</code>: \\(O(mn)\\)</li> </ul> <p>Notes</p> <p>The insertion operator will already remove any points that are dominated by the new point so that the front invariants are never broken. For this reason, unlike in a spatial container, the insertion operator might fail in fronts. This <code>insert</code> function returns an iterator to the new element and a boolean indicating if an element has been inserted. </p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>pf.insert({ {1.49101, 3.24052, 0.724771}, 24});\npf.erase({1.49101, 3.24052, 0.724771});\n</code></pre> Python <pre><code>pf.insert([pareto.point([1.49101, 3.24052, 0.724771]), 24])\ndel pf[1.49101, 3.24052, 0.724771]\n</code></pre>"},{"location":"front-container/observers/","title":"Observers","text":"Method Multimap Returns the function that compares keys <code>key_compare key_comp() const noexcept;</code> Returns the function that compares keys in objects of type value_type <code>value_compare value_comp() const noexcept</code> SpatialMap Returns the function that compares keys in a single dimension <code>dimension_compare dimension_comp() const noexcept;</code> <p>Return value</p> <p>A callable function that compares dimensions, keys, or values.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>These functions return copies of the container's constructor argument <code>comp</code>, or a wrappers around these copies. </p> <p>Example</p> C++ <pre><code>auto fn = pf.dimension_comp();\nif (fn(2.,3.)) {\n    std::cout &lt;&lt; \"2 is less than 3\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"2 is not less than 3\" &lt;&lt; std::endl;\n}\n</code></pre> Output <pre><code>2 is less than 3\n</code></pre>"},{"location":"front-container/relational-operators/","title":"Relational Operators","text":"<p>These are non-member functions.</p> Method Multimap Compares the values in the multimap <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator==(const front&lt;K, M, T, C, A&gt; &amp;lhs, const front&lt;K, M, T, C, A&gt; &amp;rhs);</code> <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator!=(const front&lt;K, M, T, C, A&gt; &amp;lhs, const front&lt;K, M, T, C, A&gt; &amp;rhs);</code> FrontContainer Front-Front Comparison <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const front&lt;K, M, T, C&gt; &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs);</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const front&lt;K, M, T, C&gt; &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const front&lt;K, M, T, C&gt; &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const front&lt;K, M, T, C&gt; &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> Front-Point Comparison <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const front&lt;K, M, T, C&gt; &amp;lhs, const typename front&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const front&lt;K, M, T, C&gt; &amp;lhs, const typename front&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const front&lt;K, M, T, C&gt; &amp;lhs, const typename front&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const front&lt;K, M, T, C&gt; &amp;lhs, const typename front&lt;K, M, T, C&gt;::key_type &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;(const typename front&lt;K, M, T, C&gt;::key_type &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;(const typename front&lt;K, M, T, C&gt;::key_type &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&lt;=(const typename front&lt;K, M, T, C&gt;::key_type &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <code>template &lt;typename K, size_t M, typename T, typename C&gt; bool operator&gt;=(const typename front&lt;K, M, T, C&gt;::key_type &amp;lhs, const front&lt;K, M, T, C&gt; &amp;rhs)</code> <p>Parameters</p> <ul> <li><code>lhs</code>, <code>rhs</code> - <code>front</code>s or <code>key_type</code>s whose contents to compare</li> </ul> <p>Return value</p> <ul> <li><code>operator==</code>, <code>operator!=</code>: <code>true</code> if the internal contents of the <code>front</code>s are equal, false otherwise. </li> <li><code>operator&lt;</code>, <code>operator&gt;</code>, <code>operator&lt;=</code>, <code>operator&gt;=</code>: true if front <code>lhs</code> (or a front containing only <code>lhs</code> as a point) dominates <code>rhs</code></li> </ul> <p>Complexity</p> <ul> <li><code>operator==</code>, <code>operator!=</code>: \\(O(mn)\\)</li> <li><code>operator&lt;</code>, <code>operator&gt;</code>, <code>operator&lt;=</code>, <code>operator&gt;=</code>: \\(O(m n \\log n)\\) for fronts and \\(O(m \\log n)\\) for points</li> </ul> \\[ O(1) \\] <p>Notes</p> <p>In addition to the equality and inequality operators defined for spatial containers, the front contains includes relational operators.</p> <p>In the context of fronts, <code>operator&lt;</code> return true if the front <code>lhs</code> dominates the front <code>rhs</code>. When one of these parameters is a point, we treat this point as if it were front with a single point.  </p> <p>Info</p> <p>Although these operators could be defined in other ways, the operators <code>operator&lt;</code>,  <code>operator&gt;</code>,  <code>operator&lt;=</code>,  <code>operator&gt;=</code> as defined here are are later useful for <code>pareto::archive</code> containers, which need to sort fronts by their dominance relationships.</p> <p>Example</p> C++ <pre><code>front&lt;double, 3, unsigned&gt; pf3(pf);\nif (pf == pf3) {\n    std::cout &lt;&lt; \"The fronts have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (pf.size() != pf3.size()) {\n        std::cout &lt;&lt; \"The fronts do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The fronts might not have the same elements\"\n                  &lt;&lt; std::endl;\n    }\n}\n\nfront&lt;double, 3, unsigned&gt; pf4(pf.begin(), pf.end());\nif (pf == pf4) {\n    std::cout &lt;&lt; \"The fronts have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (pf.size() != pf4.size()) {\n        std::cout &lt;&lt; \"The fronts do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The fronts might not have the same elements\"\n                  &lt;&lt; std::endl;\n    }\n}\n\nif (pf_star &lt; pf) {\n    std::cout &lt;&lt; \"pf* dominates pf\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"pf* does not dominate pf\" &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>pf3 = pareto.front(pf)\nif pf == pf3:\n    print('The containers have the same elements')\nelse:\n    if len(pf) != len(pf3):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n\npf4 = pareto.front()\nfor [k, v] in pf:\n    pf4[k] = v\n\nif pf == pf4:\n    print('The containers have the same elements')\nelse:\n    if len(pf) != len(pf4):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n\nif pf_star &lt; pf:\n    print('pf* dominates pf')\nelse:\n    print('pf* does not dominate pf')\n</code></pre> Output <pre><code>The fronts have the same elements\nThe fronts do not have the same elements\npf* dominates pf\n</code></pre>"},{"location":"front-container/types/","title":"Types","text":"<p>This table summarizes the public types in a <code>pareto::front&lt;K,M,T,C&gt;</code>:</p> Concept/Type Name Type Notes Container <code>value_type</code> <code>container_type::value_type</code> The pair key is <code>const</code>, like in other associative containers <code>reference</code> <code>value_type&amp;</code> <code>const_reference</code> <code>value_type const &amp;</code> <code>iterator</code> Iterator pointing to a <code>value_type</code> A LegacyBidirectionalIterator convertible to <code>const_iterator</code> <code>const_iterator</code> Iterator pointing to a <code>const value_type</code> Implements LegacyBidirectionalIterator concept <code>difference_type</code> A signed integer <code>size_type</code> An unsigned integer ReversibleContainer <code>reverse_iterator</code> <code>std::reverse_iterator&lt;iterator&gt;</code> <code>const_reverse_iterator</code> <code>std::reverse_iterator&lt;const_iterator&gt;</code> AssociativeContainer <code>key_type</code> <code>pareto::point&lt;K,M&gt;</code> Unlike in <code>value_type</code>, <code>key_type</code>  is not const, so you can use it to construct and manipulate new points <code>mapped_type</code> <code>T</code> <code>key_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>key_compare</code> defines a lexicographic ordering relation over keys using <code>dimension_compare</code> <code>value_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>value_compare</code> defines an ordering relation over <code>value_type</code> using <code>key_compare</code> AllocatorAwareContainer <code>allocator_type</code> <code>container_type::allocator_type</code> <code>allocator_type::value_type</code> is the same as <code>value_type</code> SpatialContainer <code>dimension_type</code> <code>K</code> <code>dimension_compare</code> <code>container_type::dimension_compare</code>, or <code>std::less&lt;K&gt;</code> by default <code>dimension_compare</code> defines an ordering relation over each <code>key_value</code> dimension using <code>C</code> <code>box_type</code> <code>pareto::query_box&lt;dimension_type, M&gt;</code> <code>predicate_list_type</code> <code>pareto::predicate_list&lt;dimension_type, M, T&gt;</code> SpatialAdapter <code>container_type</code> <code>C</code> <code>C</code> needs to follow the SpatialContainer concept <p>Notes</p> <p>The underlying container <code>C</code> (or <code>front::container_type</code>) used to store the values also needs to be a SpatialContainer. The allocator type and comparison functions are provided by these containers. If no container is provided, the default <code>pareto::spatial_map</code> is used as default. </p> <p>Concepts</p> <p>All other requirements of a SpatialContainer also apply here. Even if you only intend to use fronts in your application, we recommend you to read the sections on spatial containers.</p> <p>Container Adapters</p> <p>The type names and template parameters for the SpatialAdapter concept are inspired by other container adapters, such as <code>std::stack</code>. However, <code>pareto::front</code> is both an adapter and an extension of <code>SpatialContainer</code>. That is, unlike <code>std::stack</code>, its interface expands on top of the underlying container rather than limiting it.</p>"},{"location":"front-container/indicators/cardinality/","title":"Cardinality","text":"Method FrontContainer <code>double coverage(const front &amp;rhs) const</code> <code>double coverage_ratio(const front &amp;rhs) const</code> <p>Parameters</p> <ul> <li><code>rhs</code> - front being compared</li> </ul> <p>Return value</p> <ul> <li>C-metric indicator</li> </ul> <p>Complexity</p> \\[ O(m n \\log n) \\] <p>Notes</p> <p>Cardinality indicators compare two fronts and indicate how many points in one front are non-dominated by points in the other front. The coverage ratio compares which front dominates more points in the other with <code>lhs.coverage(rhs) / rhs.coverage(lhs)</code>.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>std::cout &lt;&lt; \"C-metric: \" &lt;&lt; pf.coverage(pf2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Coverage ratio: \" &lt;&lt; pf.coverage_ratio(pf2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"C-metric: \" &lt;&lt; pf2.coverage(pf) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Coverage ratio: \" &lt;&lt; pf2.coverage_ratio(pf) &lt;&lt; std::endl;\n</code></pre> Python <pre><code>print('C-metric:', pf.coverage(pf2))\nprint('Coverage ratio:', pf.coverage_ratio(pf2))\nprint('C-metric:', pf2.coverage(pf))\nprint('Coverage ratio:', pf2.coverage_ratio(pf))\n</code></pre> Output <pre><code>C-metric: 0\nCoverage ratio: 0\nC-metric: 1\nCoverage ratio: inf\n</code></pre>"},{"location":"front-container/indicators/convergence/","title":"Convergence","text":"Method FrontContainer Convergence Indicators <code>double gd(const front &amp;reference) const</code> <code>double igd(const front &amp;reference) const</code> <code>double igd_plus(const front &amp;reference) const</code> <code>double hausdorff(const front &amp;reference) const</code> Standard deviation of Convergence Indicators <code>double std_gd(const front &amp;reference) const</code> <code>double std_igd(const front &amp;reference) const</code> <code>double std_igd_plus(const front &amp;reference) const</code> <p>Parameters</p> <ul> <li><code>reference</code> - Target front. An estimate of the best front possible for the problem.</li> </ul> <p>Return value</p> <ul> <li>How far the current front is from the reference front</li> </ul> <p>Complexity</p> \\[ O(m n \\log n) \\] <p>Notes</p> <p>Convergence indicators measure the distance from a front approximation to the exact Pareto front, or at least a better approximation of the exact front.</p> <p>Example</p> C++ <pre><code>front&lt;double, 3, unsigned&gt; pf_star({min, max, min});\nfor (const auto &amp;[p,v] : pf) {\n    pf_star(p[0] - 1.0, p[1] + 1.0, p[2] - 1.0) = v;\n}\nstd::cout &lt;&lt; \"GD: \" &lt;&lt; pf.gd(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDGD: \" &lt;&lt; pf.std_gd(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"IGD: \" &lt;&lt; pf.igd(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDGD: \" &lt;&lt; pf.std_igd(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Hausdorff: \" &lt;&lt; pf.hausdorff(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"IGD+: \" &lt;&lt; pf.igd_plus(pf_star) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"STDIGD+: \" &lt;&lt; pf.std_igd_plus(pf_star) &lt;&lt; std::endl;\n</code></pre> Python <pre><code>pf_star = pareto.front(['min', 'max', 'min'])\nfor [p, v] in pf:\n    pf_star[p[0] - 1.0, p[1] + 1.0, p[2] - 1.0] = v\n\nprint('GD:', pf.gd(pf_star))\nprint('STDGD:', pf.std_gd(pf_star))\nprint('IGD:', pf.igd(pf_star))\nprint('STDGD:', pf.std_igd(pf_star))\nprint('Hausdorff:', pf.hausdorff(pf_star))\nprint('IGD+:', pf.igd_plus(pf_star))\nprint('STDIGD+:', pf.std_igd_plus(pf_star))\n</code></pre> Output <pre><code>GD: 1.54786\nSTDGD: 0.0465649\nIGD: 1.52137\nSTDGD: 0.0472864\nHausdorff: 1.54786\nIGD+: 1.48592\nSTDIGD+: 0.0522492\n</code></pre>"},{"location":"front-container/indicators/correlation/","title":"Correlation","text":"Method FrontContainer Conflict / Harmony <code>dimension_type direct_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double maxmin_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double conflict(const size_t a, const size_t b) const</code> Normalized Conflict / Harmony <code>[[nodiscard]] double normalized_direct_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double normalized_maxmin_conflict(const size_t a, const size_t b) const</code> <code>[[nodiscard]] double normalized_conflict(const size_t a, const size_t b) const</code> <p>Parameters</p> <ul> <li><code>a</code>, <code>b</code> - dimension indices</li> </ul> <p>Return value</p> <ul> <li>The direct, max-min, or non-parametric conflict between two objectives. </li> <li>The normalized indicators divide the results by the maximum value possible for that correlation indicator.</li> </ul> <p>Complexity</p> <ul> <li>Direct: \\(O(n)\\)</li> <li>Max-min: \\(O(n)\\)</li> <li>Non-parametric: \\(O(n \\log n)\\)</li> </ul> <p>Notes</p> <p>Correlation indicators can measure the relationship between objectives in a front. The more conflict between a pair of objectives, the more important it is to focus on these objectives. Objectives with little conflict are good candidates to be latter aggregated into a simpler objective function.</p> <p>Example</p> C++ <pre><code>std::cout &lt;&lt; \"Direct conflict(0,1): \" &lt;&lt; pf.direct_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized direct conflict(0,1): \" &lt;&lt; pf.normalized_direct_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Maxmin conflict(0,1): \" &lt;&lt; pf.maxmin_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized maxmin conflict(0,1): \" &lt;&lt; pf.normalized_maxmin_conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Non-parametric conflict(0,1): \" &lt;&lt; pf.conflict(0,1) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized conflict(0,1): \" &lt;&lt; pf.normalized_conflict(0,1) &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"Direct conflict(1,2): \" &lt;&lt; pf.direct_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized direct conflict(1,2): \" &lt;&lt; pf.normalized_direct_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Maxmin conflict(1,2): \" &lt;&lt; pf.maxmin_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized maxmin conflict(1,2): \" &lt;&lt; pf.normalized_maxmin_conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Non-parametric conflict(1,2): \" &lt;&lt; pf.conflict(1,2) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Normalized conflict(1,2): \" &lt;&lt; pf.normalized_conflict(1,2) &lt;&lt; std::endl;\n</code></pre> Python <pre><code>print('Direct conflict(0,1):', pf.direct_conflict(0, 1))\nprint('Normalized direct conflict(0,1):', pf.normalized_direct_conflict(0, 1))\nprint('Maxmin conflict(0,1):', pf.maxmin_conflict(0, 1))\nprint('Normalized maxmin conflict(0,1):', pf.normalized_maxmin_conflict(0, 1))\nprint('Non-parametric conflict(0,1):', pf.conflict(0, 1))\nprint('Normalized conflict(0,1):', pf.normalized_conflict(0, 1))\n\nprint('Direct conflict(1,2):', pf.direct_conflict(1, 2))\nprint('Normalized direct conflict(1,2):', pf.normalized_direct_conflict(1, 2))\nprint('Maxmin conflict(1,2):', pf.maxmin_conflict(1, 2))\nprint('Normalized maxmin conflict(1,2):', pf.normalized_maxmin_conflict(1, 2))\nprint('Non-parametric conflict(1,2):', pf.conflict(1, 2))\nprint('Normalized conflict(1,2):', pf.normalized_conflict(1, 2))\n</code></pre> Output <pre><code>Direct conflict(0,1): 34.3539\nNormalized direct conflict(0,1): 0.360795\nMaxmin conflict(0,1): 7.77615\nNormalized maxmin conflict(0,1): 0.388808\nNon-parametric conflict(0,1): 184\nNormalized conflict(0,1): 0.92\nDirect conflict(1,2): 32.0107\nNormalized direct conflict(1,2): 0.280515\nMaxmin conflict(1,2): 5.85805\nNormalized maxmin conflict(1,2): 0.292903\nNon-parametric conflict(1,2): 146\nNormalized conflict(1,2): 0.73\n</code></pre>"},{"location":"front-container/indicators/distribution/","title":"Distribution","text":"Method FrontContainer Front Distribution <code>[[nodiscard]] double uniformity() const</code> <code>[[nodiscard]] double average_distance() const</code> <code>[[nodiscard]] double average_nearest_distance(size_t k = 5) const</code> <code>[[nodiscard]] double average_crowding_distance() const</code> Point Distribution <code>double crowding_distance(const_iterator element, key_type worst_point, key_type ideal_point) const</code> <code>double crowding_distance(const_iterator element) const</code> <code>double crowding_distance(const key_type &amp;point) const</code> <p>Parameters</p> <ul> <li><code>k</code> - number of nearest elements to consider</li> <li><code>element</code> - element for which we want the crowding distance (see below)</li> <li><code>key_type</code> - point for which we want the crowding distance (see below)</li> <li><code>worst_point</code>, <code>ideal_point</code> - reference extreme points for the crowding distance</li> </ul> <p>Return value</p> <ul> <li><code>uniformity</code>: minimal distance between two points in the front</li> <li><code>average_distance</code>: average distance between points in the front</li> <li><code>average_nearest_distance</code>: average distance between points and their nearest points</li> <li><code>average_crowding_distance</code>: average crowding distance (see below) between points in the front</li> <li><code>crowding_distance</code>: the crowding distance of a single element</li> </ul> <p>Complexity</p> <ul> <li><code>uniformity</code>: \\(O(m n \\log n)\\)</li> <li><code>average_distance</code>: \\(O(m n^2)\\)</li> <li><code>average_nearest_distance</code>: \\(O(k m n \\log n)\\)</li> <li><code>average_crowding_distance</code>: \\(O(m n \\log n)\\)</li> <li><code>crowding_distance</code>: \\(O(m \\log n)\\)</li> </ul> <p>Notes</p> <p>Distribution indicators measure how uniformly the points are distributed on the front. This is useful for a better approximation of the target front.</p> <p>The Crowding Distance</p> <p>The crowding distance indicator replaces the usual euclidean distance between points (\\(\\sqrt{\\sum_{i=1}^m (p_i - q_i)^2}\\)) with the coordinate distance between the nearest points in each dimension (\\(\\sum_{i=1}^m | p_i - nearest_{1}(p_i, m) | + | p_i - nearest_2(p_i, m)|\\)).</p> <p>Example</p> C++ <pre><code>std::cout &lt;&lt; \"Uniformity: \" &lt;&lt; pf.uniformity() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average distance: \" &lt;&lt; pf.average_distance() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average nearest distance: \" &lt;&lt; pf.average_nearest_distance(5) &lt;&lt; std::endl;\nauto near_origin = pf.find_nearest({0.0, 0.0, 0.0});\nstd::cout &lt;&lt; \"Crowding distance: \" &lt;&lt; pf.crowding_distance(near_origin) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Average crowding distance: \" &lt;&lt; pf.average_crowding_distance() &lt;&lt; std::endl;\n</code></pre> Python <pre><code>print(\"Uniformity:\", pf.uniformity())\nprint(\"Average distance:\", pf.average_distance())\nprint(\"Average nearest distance:\", pf.average_nearest_distance(5))\nnear_origin = next(pf.find_nearest(pareto.point([0.0, 0.0])))\nprint(\"Crowding distance:\", pf.crowding_distance(near_origin[0]))\nprint(\"Average crowding distance:\", pf.average_crowding_distance())\n</code></pre> Output <pre><code>Uniformity: 0.355785\nAverage distance: 2.75683\nAverage nearest distance: 1.45177\nCrowding distance: 3.04714\nAverage crowding distance: 4.04349\n</code></pre>"},{"location":"front-container/indicators/hypervolume/","title":"Hypervolume","text":"Method FrontContainer Exact Hypervolume <code>dimension_type hypervolume() const</code> <code>dimension_type hypervolume(key_type reference_point) const</code> Monte-Carlo Hypervolume <code>dimension_type hypervolume(size_t sample_size) const</code> <code>dimension_type hypervolume(size_t sample_size, const key_type &amp;reference_point) const</code> <p>Parameters</p> <ul> <li><code>reference_point</code> - point used as reference for the hypervolume calculation. When not provided, it defaults to the <code>nadir()</code> point.</li> <li><code>sample_size</code> - number of samples for the hypervolume estimate</li> </ul> <p>Return value</p> <ul> <li>Hypervolume indicator</li> </ul> <p>Complexity</p> <ul> <li>Exact hypervolume: \\(O(n^{m-2} \\log n)\\)</li> <li>Monte-Carlo hypervolume approximation:  \\(O(s m \\log n)\\), where \\(s\\) is the number of samples</li> </ul> <p>Notes</p> <p>Because the solutions in a front are incomparable, we need performance indicators to infer the quality of a front. Indicators can measure several front attributes, such as cardinality, convergence, distribution, and spread. Correlation indicators can also estimate the relationship between objectives in a set.</p> <p>The most popular indicator of a front quality is its hypervolume, as it measures both convergence and distribution quality. The front hypervolume refers to the total hypervolume dominated by the front. </p> <p>Hypervolume Approximation</p> <p>When \\(m\\) is large, the exact hypervolume calculation becomes impractical. Our benchmarks provide a reference on the impact of these approximations.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>std::cout &lt;&lt; \"Exact hypervolume: \" &lt;&lt; pf.hypervolume(pf.nadir()) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Hypervolume approximation (10000 samples): \" &lt;&lt; pf.hypervolume(10000, pf.nadir()) &lt;&lt; std::endl;\n</code></pre> Python <pre><code>print('Exact hypervolume:', pf.hypervolume(pf.nadir()))\nprint('Hypervolume approximation (10000 samples):', pf.hypervolume(10000, pf.nadir()))\n</code></pre> Output <pre><code>Exact hypervolume: 55.4029\nHypervolume approximation (10000 samples): 54.4734\n</code></pre>"},{"location":"integration/installing/","title":"Installing","text":"<p>Get one of binary packages from the release section. These file names have the following syntax:</p> <ul> <li>Python Binary <ul> <li>This is only the binary for Python.</li> <li>Copy this file to your site-packages directory or to your project directory.</li> <li>No need to <code>pip install</code></li> </ul> <li>pareto-&lt; version &gt;-&lt; OS &gt;.&lt; package extension &gt;<ul> <li>These packages contain the Python bindings and the C++ library.</li> </ul> </li> <li>Binary Packages &lt; OS &gt;<ul> <li>These files contain all packages for a given OS.</li> </ul> </li> <p>If using one the installers, make sure you install the Python bindings to your site-packages directory (this is the default directory for most packages). You can find your site-packages directory with:</p> <pre><code>python -c \"from distutils.sysconfig import get_python_lib; print(get_python_lib());\"\n</code></pre> <p>These binaries refer to the last release version. If you need a more recent version of pareto, you can download the binary packages from the CI artifacts or build the library from the source files.</p> <p>Once the package is installed, you can use the Python library with</p> <pre><code>import pareto\n</code></pre> <p>or link your C++ program to the library and include the directories where you installed pareto.</p> <p>Unless you changed the default options, the C++ library is likely to be in <code>/usr/local/</code> (Linux / Mac OS) or <code>C:/Program Files/</code> (Windows). The installer will try to find the directory where you usually keep your libraries but that's not always perfect.</p> <p>CMake should be able to locate the <code>ParetoConfig.cmake</code> script automatically if you installed the library under <code>/usr/local/</code> (Linux / Mac OS).</p> <p>find_package on windows</p> <p>There is no easy default directory for <code>find_package</code> on windows. You have to set it yourself.</p>"},{"location":"integration/building/building/","title":"Building","text":"<p>After installing or updating the dependencies, clone the project with</p> <pre><code>git clone https://github.com/alandefreitas/pareto.git\ncd pareto\n</code></pre> <p>and then build it with</p> Ubuntu <pre><code>mkdir build\ncd build\ncmake -version\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\ncmake --build . -j 2 --config Release\n# The next command for installing\nsudo cmake --install .\n# The next command for building the packages / installers\nsudo cpack .\n</code></pre> Mac OS <pre><code>mkdir build\ncd build\ncmake -version\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\ncmake --build . -j 2 --config Release\n# The next command for installing\ncmake --install .\n# The next command for building the packages / installers\ncpack .\n</code></pre> Windows <pre><code>mkdir build\ncd build\ncmake -version\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"/O2\"\ncmake --build . -j 2 --config Release\n# The next command for installing\ncmake --install .\n# The next command for building the packages / installers\ncpack .\n</code></pre>"},{"location":"integration/building/dependencies/","title":"Dependencies","text":"<p>C++</p> <p>Update your C++ compiler to at least C++17:</p> Ubuntu <pre><code># install GCC10\nsudo apt install build-essential\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\nsudo apt install gcc-10\nsudo apt install g++-10\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10\nsudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10\n# Choose gcc-10 there as the default compiler\nupdate-alternatives --config g++\n</code></pre> Mac OS <pre><code># Download clang\ncurl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz\nmkdir clang\ntar -xvJf clang.tar.xz -C clang\n# Copy the files to use/local\ncd clang/clang+llvm-11.0.0-x86_64-apple-darwin\nsudo cp -R * /usr/local/\n# Make it your default compiler\nexport CXX=/usr/local/bin/clang++\n</code></pre> Windows <p>Update your Visual Studio Compiler.</p> <p>CMake</p> <p>Update your CMake to at least CMake 3.16+. You can check your CMake version with:</p> <pre><code>cmake --version\n</code></pre> <p>If you need to update it, then</p> Ubuntu + apt <pre><code>sudo apt upgrade cmake\n</code></pre> Mac OS + Homebrew <pre><code>sudo brew upgrade cmake\n</code></pre> Website <p>Download CMake from https://cmake.org/download/ and install it</p> <p>Python</p> <p>Make sure you have Python 3.6.9+ installed:</p> <pre><code>python3 --version\n</code></pre> <p>If you need to update, then</p> Ubuntu <p>Use <code>apt-get</code> or download it from https://www.python.org/downloads/.</p> Mac OS <pre><code>sudo brew upgrade python3\n</code></pre> <p>or download the latest release version from https://www.python.org/downloads/</p> Windows <p>Download Python from https://www.python.org/downloads/ and install it</p> <p>If using a Python installer, make sure you add the application directory to your PATH environment variable.</p>"},{"location":"integration/c/embed-as-cmake-subdirectory/","title":"Embed as CMake subdirectory","text":"<p>You can use pareto directly in CMake projects as a subproject.</p> <p>Clone the whole project inside your own project:</p> <pre><code>git clone https://github.com/alandefreitas/pareto/\n</code></pre> <p>and add the subdirectory to your CMake script:</p> <pre><code>add_subdirectory(pareto)\n</code></pre> <p>When creating your executable, link the library to the targets you want:</p> <pre><code>add_executable(my_target main.cpp)\ntarget_link_libraries(my_target PRIVATE pareto)\n</code></pre> <p>Your target will be able to see the pareto headers now.</p>"},{"location":"integration/c/embed-as-header-only/","title":"Embed as header-only","text":"<p>Copy the files from the <code>source</code> directory of this project to your <code>include</code> directory.</p> <p>If you want to use <code>std::pmr</code> allocators by default, set the macro <code>BUILD_PARETO_WITH_PMR</code> before including the files.</p> C++ <pre><code>#def BUILD_PARETO_WITH_PMR\n#include &lt;pareto/front.h&gt;\n</code></pre> <p>Each header in <code>pareto</code> represents a data structure.</p> <p>!!! warning Make sure you have C++17+ installed</p>"},{"location":"integration/c/embed-with-cmake-fetchcontent/","title":"Embed with CMake FetchContent","text":"<p>FetchContent is a CMake command to automatically download the repository:</p> <pre><code>include(FetchContent)\n\nFetchContent_Declare(pareto\n        GIT_REPOSITORY https://github.com/alandefreitas/pareto\n        GIT_TAG origin/master # or whatever tag you want\n        )\n\nFetchContent_GetProperties(pareto)\nif (NOT pareto_POPULATED)\n    FetchContent_Populate(pareto)\n    add_subdirectory(${pareto_SOURCE_DIR} ${pareto_BINARY_DIR} EXCLUDE_FROM_ALL)\nendif ()\n\n# ...\ntarget_link_libraries(my_target PRIVATE pareto)\n</code></pre> <p>Your target will be able to see the pareto headers now.</p>"},{"location":"integration/c/embed-with-cpmcmake/","title":"Embed with CPM.cmake","text":"<p>CPM.cmake is a nice wrapper around the CMake FetchContent function. Install CPM.cmake and then use this command to add Pareto to your build script:</p> <pre><code>CPMAddPackage(\n        NAME Pareto\n        GITHUB_REPOSITORY alandefreitas/pareto\n        GIT_TAG origin/master # or whatever tag you want\n)\n# ...\ntarget_link_libraries(my_target PUBLIC pareto)\n</code></pre> <p>Your target will be able to see the pareto headers now.</p>"},{"location":"integration/c/find-as-cmake-package/","title":"Find as CMake package","text":"<p>If you are using CMake and have the library installed on your system, you can then find Pareto with the usual <code>find_package</code> command:</p> <pre><code>find_package(Pareto REQUIRED)\n# ...\ntarget_link_libraries(my_target PUBLIC pareto)\n</code></pre> <p>Your target will be able to see the pareto headers now.</p> <p>find_package on windows</p> <p>There is no easy default directory for find_package on windows. You have to set it yourself.</p>"},{"location":"integration/python/embed-as-project-file/","title":"Embed as project file","text":"<p>Get the python binary from the release section and put it in your project directory. You can then use the library with:</p> <pre><code>import pareto\n</code></pre>"},{"location":"integration/python/find-as-package/","title":"Find as package","text":"<p>If you have installed the library on your system, all you need in your source code is:</p> <pre><code>import pareto\n</code></pre> <p>!!! warning There's no <code>pip install pareto</code> yet. Because this is a compiled library, creating a pip package is a little more complicated. It's still in our to-do list.</p>"},{"location":"quick-start/archive-container/","title":"Archive Container","text":"<p>The <code>pareto::archive</code> container is also both an adapter and an extension of spatial containers to cache objects representing conflicting alternatives:</p> C++ <pre><code>// Three-dimensional Pareto archive\npareto::archive&lt;double, 3, unsigned&gt; m;\n</code></pre> Python <pre><code># Python Three-dimensional Pareto archive\nm = pareto.archive()\n</code></pre> <p>They are useful in dynamic applications where the best objects might not be available in the future and we might need a second best. Archives are especially useful in all dynamic applications that use fronts, such as:</p> <ul> <li>P2P networks</li> <li>multi-criteria decision making</li> <li>generate-and-test optimization algorithms</li> <li>robust optimization</li> </ul> <p>Tip</p> <p>You can think of archives as a multidimensional stack.</p> <p>Example</p> <p>This is what a two-dimensional archive would look like:</p> <p></p> <p>Plotting Archives</p> <p>The header <code>pareto/matplot/archive.h</code> includes some snippets to plot these archives with Matplot++.</p> <p>Archive Capacity</p> <p>All archive constructors include an optional parameter to define the maximum number of elements in the archive. If no maximum capacity for the archive is explicitly set, the capacity is set to \\(\\min(50 \\times 2^m, 100000)\\). The exponential factor \\(2^m\\) in this heuristic is meant to take the curse of dimensionality in consideration.</p> <p>Data scientists often use linear lists to represent these fronts, with a cost of \\(O(mn^3)\\) p\u001f\u00181 for several operations. With spatial indexes, this cost reduces to just \\(O(m \\log^2 n)\\).</p> <p>You have probably noticed by now that containers for fronts and archives have lots of use cases:</p> Use case Common keys Machine Learning Accuracy vs. Complexity vs. Time Approximation algorithms Error vs. Time Product design Investment vs. Profit vs. Safety vs. Performance  vs. Scope P2P networks Latency vs. Trust vs. Availability Robust optimization Average quality vs. Robustness Design Average quality vs. Standard deviation Systems control Performance vs. Price vs. Quality Portfolio optimization Expected return vs. Risk More... ..."},{"location":"quick-start/front-container/","title":"Front Container","text":"<p>The <code>pareto::front</code> object defines a container for Pareto fronts, which is both an adapter and an extension of the spatial containers to deal with objects representing conflicting alternatives:</p> C++ <pre><code>// Three-dimensional Pareto front\npareto::front&lt;double, 3, unsigned&gt; m;\n</code></pre> Python <pre><code># Three-dimensional Pareto front\n# The dimension will be set when you insert the first element\nm = pareto.front()\n</code></pre> <p>When inserting a new element in the front, all solutions dominated by the new solution are erased with spatial queries. </p> C++ <pre><code>front&lt;double, 2, unsigned&gt; pf;\npf(0., 1.) = 17; // Good at x[0]\npf(1., 0.) = 32; // Good at x[1]\npf(2., 1.) = 36; // Dominated by [1., 0.]\nfor (const auto &amp;[k, v] : pf) {\n    std::cout &lt;&lt; k &lt;&lt; \" -&gt; \" &lt;&lt; v &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>pf = pareto.front()\n# Good at x[0]\npf[0., 1.] = 17\n# Good at x[1]\npf[1., 0.] = 32\n# Dominated by [1., 0.]\npf[2., 1.] = 36\nfor [k, v] in pf:\n    print(k, \" -&gt; \", v)\n</code></pre> Output <pre><code>[0, 1] -&gt; 17\n[1, 0] -&gt; 32\n</code></pre> <p>Pareto fronts are useful in any application where we need to store the best objects according to a number of criteria, such as:</p> <ul> <li>finance</li> <li>multi-criteria decision making</li> <li>optimization</li> <li>machine learning</li> <li>hyper-parameter tuning</li> <li>approximation algorithms</li> <li>P2P networks</li> <li>routing algorithms</li> <li>robust optimization</li> <li>design</li> <li>systems control</li> </ul> <p>Tip</p> <p>You can think of fronts as a container for dynamic multidimensional max/min-finding. </p> <p>Example</p> <p>Suppose you want to choose between a number of investment portfolios. By looking at the historical data, you have noticed each portfolio has an average return and some average risk (something like the covariance between the assets). Because there is an exponential number of portfolio candidates, you can instead iteratively update the front with the best portfolios for your criteria and use these portfolios as a reference to test new portfolios. You would then have front like the following:</p> <p></p> <p>These objectives often go in different directions (e.g., minimize price vs. maximize quality). In these situations, you can specify a direction for each dimension.</p> C++ <pre><code>// C++ Three-dimensional Pareto front\npareto::front&lt;double, 2, unsigned&gt; m({min, max});\n</code></pre> Python <pre><code># Python Three-dimensional Pareto front\nm = pareto.front(['min','max'])\n</code></pre> <p>Example</p> <p></p> <p>In more than two dimensions, we usually represent the fronts with parallel coordinates:</p> <p></p> <p>Plotting Fronts</p> <p>The header <code>pareto/matplot/front.h</code> includes some snippets to plot these fronts with Matplot++.</p> <p>Data scientists often use linear lists to represent these fronts, with a cost of \\(O(mn^2)\\) for several operations. This makes it unfeasible to represent the thousands or millions of solutions we usually have in a non-polynomial multidimensional optimization problem due to the curse of dimensionality. With spatial indexes, this cost reduces to only \\(O(m \\log n)\\).</p> <p>Indicators</p> <p>Because Pareto fronts include solutions that are incomparable by definition, we need metrics to tell us the quality of a front. The <code>front</code> objects implement lots of performance indicators that can give us measures of:</p> <ul> <li>hypervolume</li> <li>convergence</li> <li>cardinality</li> <li>distribution</li> <li>correlation</li> </ul>"},{"location":"quick-start/interfaces/","title":"Interfaces","text":"<p>These containers formally follow and extend on the named requirements of the C++ standard library. If you know how to use <code>std::map</code>, you already know how to use 90% any of these containers. You can use <code>m.erase(it)</code>, <code>m.insert(v)</code>, <code>m.empty()</code>, <code>m.size()</code>, <code>m.begin()</code> , and <code>m.end()</code> like you would with any other associative container.</p> <p>Python Bindings</p> <p>Although this library is completely implemented in C++17, because data scientists love Python, we also include Python bindings for all these data structures. We further replicate the syntax of the native Python data structures, so that <code>m.erase(k)</code> becomes <code>del m[k]</code>, <code>if m.empty()</code> becomes <code>if m:</code>, and  <code>m.insert(k,v)</code> becomes <code>m[k] = v</code>. If you're a C++ programmer using Python, the C++ container syntax is still available in Python.</p> <p>C++ Concepts / Named Requirements</p> <p>Formally, these containers implement the Container, ReversibleContainer, AllocatorAwareContainer, and AssociativeContainer Concepts / Named Requirements. Their iterators also implement the LegacyBidirectionalIterator concepts and they can use memory allocators that follow the Allocator concept. The extensions are formally defined as the concepts SpatialContainer, FrontContainer, and ArchiveContainer, whose pre- and post- conditions are checked with our unit tests.</p> <p>All that means they work transparently with other native data structures. We include lots of unit tests, benchmarks, and continuous integration to make sure this compatibility is maintained. This also means they're easy to integrate with other libraries. For instance, the source file <code>examples/matplotpp_example.cpp</code> and the headers in <code>source/pareto/matplot</code> exemplify how to create the plots you are seeing in this documentation with Matplot++. </p>"},{"location":"quick-start/performance/","title":"Performance","text":"<p>The problem of storing multidimensional data is simple to explain but not so easy to solve. It might seem like linear lists, even with their \\(O(n^2)\\) pair-wise comparisons, wouldn't fair much worse than these alternative containers. Even large scale multidimensional problems have at least some subproblems with less than a hundred solutions.</p> <p>One common problem in scientific applications is that most of these containers can only outperform linear lists when storing thousands of objects. This happens mainly because data structures based on trees require one memory allocation per node.</p> <p>Setting the Number of Dimensions</p> <p>The first strategy we use to mitigate this problem is to allow the number of dimensions to be set at compile-time or runtime. This reduces the number of memory allocations because setting the dimension at runtime require one extra memory allocation per node.</p> <p>Memory Allocation</p> <p>However, to make these associative containers fully competitive with linear lists in all scenarios, we need memory allocators. To avoid one dynamic allocation per node, pool allocators, like linear lists, pre-allocate fixed-size chucks of memory for tree nodes.</p> <p>All containers implement the AllocatorAwareContainer concept, that includes constructors that can receive custom allocators. All memory allocations happen through these custom allocators. If no allocator is provided, the build script will try to infer a proper allocator for each data structure.</p>"},{"location":"quick-start/spatial-containers/","title":"Spatial Containers","text":"<p>This library defines and implements spatial containers, which are an extension of the AssociativeContainer named requirement for multi-dimensional containers:</p> C++ <pre><code>// Unidimensional associative container \nstd::map&lt;double, unsigned&gt; m;\n// Multidimensional associative container\npareto::spatial_map&lt;double, 3, unsigned&gt; n;\n</code></pre> Python <pre><code># Unidimensional associative container\nm = sortedcontainers.SortedDict()\n# Multidimensional associative container\nn = pareto.spatial_map(3)\n</code></pre> <p>Spatial containers allow you to later find its elements with query iterators:</p> C++ <pre><code>spatial_map&lt;double, 2, unsigned&gt; m;\nm(-2.5, -1.5) = 17;\nm(-2.1, -0.5) = 32;\nm(-1.6, 0.9) = 36;\nm(-0.6, 0.9) = 13;\nm(-0.5, 0.8) = 32;\nstd::cout &lt;&lt; \"Closest elements to [0, 0]:\" &lt;&lt; std::endl;\nfor (auto it = m.find_nearest({0.,0.}, 2); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; \"Elements between [-1, -1] and [+1, +1]:\" &lt;&lt; std::endl;\nfor (auto it = m.find_intersection({-1.,-1.}, {+1, +1}); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>m = pareto.spatial_map()\nm[-2.5, -1.5] = 17\nm[-2.1, -0.5] = 32\nm[-1.6, 0.9] = 36\nm[-0.6, 0.9] = 13\nm[-0.5, 0.8] = 32\nprint(\"Closest elements to [0, 0]:\")\nfor [k, v] in m.find_nearest(pareto.point([0.,0.]), 2):\n    print(k, \":\", v)\n\nprint(\"Elements between [-1, -1] and [+1, +1]:\")\nfor [k, v] in m.find_intersection(pareto.point([-1.,-1.]), pareto.point([+1, +1])):\n    print(k, \":\", v)\n</code></pre> Output <pre><code>Closest elements to [0, 0]:\n[-0.5, 0.8]: 32\n[-0.6, 0.9]: 13\nElements between [-1, -1] and [+1, +1]:\n[-0.6, 0.9]: 13\n[-0.5, 0.8]: 32\n</code></pre> <p>Multi-dimensional associative containers are useful in applications where you need to simultaneously order objects according to a number for criteria, such as in:</p> <ul> <li>games</li> <li>maps</li> <li>nearest neighbor search</li> <li>range search</li> <li>compression algorithms</li> <li>statistics</li> <li>mechanics</li> <li>graphics libraries</li> <li>database queries. </li> </ul> <p>Many applications already need to implement such kinds of containers, although in a less generic way.</p> <p>Complexity</p> <p>Inserting, removing, and finding solutions cost \\(O(m \\log n)\\), where \\(m\\) is the number of dimensions and \\(n\\) is the number of elements. </p> <p>Unidimensional Spatial Containers</p> <p>When \\(m=1\\), a <code>pareto::spatial_map</code> internally decays into a <code>std::multimap</code>, which is useful for applications where we don't know \\(m\\) beforehand or need to handle many possible values of \\(m\\) without maintaining two different implementations.</p> <p>Runtime dimensions</p> <p>Some problems are so dynamic that even the number of dimensions changes at runtime. In these applications, you can set the number of compile-time dimensions to <code>0</code>, and the containers will accept keys with any number of dimensions. This, of course, comes at a cost of an extra dynamic memory allocation per element.</p> <p>The usual <code>find(k)</code>, <code>lower_bound(k)</code>, and <code>upper_bound(k)</code> functions of unidimensional maps are not enough for spatial containers. We fix this with query iterators, that explore the spatial data according to a list of predicates. Queries can limit or expand their search region with a conjunction of predicates such as intersections, disjunctions, and nearest points.</p> <p>Predicate Lists</p> <p>To make queries more efficient, the <code>pareto::predicate_list</code> object compresses redundant predicates and sorts these predicates by how restrictive they are. All tree nodes store their minimum bounding rectangles, and these underlying data structures are then explored to avoid nodes that might not pass the predicate list. This allows us to find each query element in \\(O(m \\log n)\\) time, regardless of how complex the query is.</p>"},{"location":"spatial-containers/allocators/","title":"Allocators","text":"Method AllocatorAwareContainer <code>allocator_type get_allocator() const noexcept;</code> <p>Return value</p> <p>The associated allocator.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>One of the reasons associative containers perform much worse than sequence containers for small containers is that associative containers, being internally represented as trees, require one memory allocation for each new element. An allocator is an object that defines how memory is allocated for a container. Because tree nodes usually have fixed size, pool allocators for associative containers usually allocate a large block of memory for nodes before new nodes are created. Thus, associative containers can have a performance similar to sequential containers even when the container has few elements.  </p> <p>The Allocator Concept</p> <p>An allocator must implement the Allocator concept, while an allocator aware container must implement the AllocatorAwareContainer concept, which includes constructors accepting allocators as parameters. Internally, a container that is allocator aware should use only the allocator to create new nodes.</p> <p>Besides the constructors defined in the previous section, spatial containers also define the function <code>allocator_type get_allocator() const;</code> to return the current allocator being used by the container. If two allocators compare equal, that means they use the same memory resources. When two containers do not use the same allocator, the move constructor costs \\(O(mn)\\) instead of \\(O(1)\\).</p> <p>Default Allocator</p> <p>By default, all containers in this library use a <code>std::pmr::polymorphic_allocator</code> with an internal <code>std::pmr::unsynchronized_pool_resource</code> as their default allocator (see our Benchmarks). </p> <p>PMR implementations</p> <p>Because many compilers haven't completely implemented <code>std::pmr</code> yet, the build script will look for <code>std::pmr</code> and fallback to <code>std::allocator</code> if <code>std::pmr</code> is not available yet.</p> <p>Note on previous versions of Pareto</p> <p>Previous versions of this library included a stateful memory allocator based on pools and slots. Because the C++ requirements for allocators are not kind to simple stateful allocators whose elements have fixed size, our allocator ended up looking more and more like a simpler version of the <code>std::pmr::polymorphic_allocator</code>.  Fortunately, these <code>std::pmr</code> is now part of the standard library and our containers are now allocator aware, so you can just use <code>pmr</code> or any other efficient allocator for these containers. </p> <p>Example</p> C++ <pre><code>#include &lt;pareto/spatial_map.h&gt;\n// ...\npareto::spatial_map&lt;double, 3, unsigned&gt; m;\n// Get a copy of the container allocator\nauto alloc = m.get_allocator();\n</code></pre>"},{"location":"spatial-containers/capacity-and-reference-points/","title":"Capacity and Reference Points","text":"Method MultimapContainer Check size <code>[[nodiscard]] bool empty() const noexcept;</code> <code>[[nodiscard]] size_type size() const noexcept;</code> <code>[[nodiscard]] size_type max_size() const noexcept;</code> SpatialContainer Check dimensions <code>[[nodiscard]] size_t dimensions() const noexcept;</code> Get max/min values <code>dimension_type max_value(size_t dimension) const;</code> <code>dimension_type min_value(size_t dimension) const;</code> <p>Parameters</p> <ul> <li><code>dimension</code> - index of the dimension for which we want the minimum or maximum value</li> </ul> <p>Return value</p> <ul> <li><code>empty()</code>- <code>true</code> if and only if container (equivalent but more efficient than <code>begin() == end()</code>)</li> <li><code>size()</code> - The number of elements in the container</li> <li><code>max_size()</code> - An upper bound on the maximum number of elements the container can hold</li> <li><code>dimensions()</code> - Number of dimensions in the container (same as <code>M</code>, when <code>M != 0</code>)</li> <li><code>max_value()</code> - Maximum value in a given dimension</li> <li><code>min_value()</code> - Minimum value in a given dimension</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>Because all container nodes keep their minimum bounding rectangles, we can get these values in constant time.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>if (!m.empty()) {\n    std::cout &lt;&lt; \"Map is not empty\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"Map is empty\" &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; m.size() &lt;&lt; \" elements in the spatial map\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; m.dimensions() &lt;&lt; \" dimensions\" &lt;&lt; std::endl;\nfor (size_t i = 0; i &lt; m.dimensions(); ++i) {\n    std::cout &lt;&lt; \"Min value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; m.min_value(i) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Max value in dimension \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; m.max_value(i) &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>if m:\n    print('Map is not empty')\nelse:\n    print('Map is empty')\n\nprint(len(m), 'elements in the spatial map')\nprint(m.dimensions(), 'dimensions')\nfor i in range(m.dimensions()):\n    print('Min value in dimension', i, ': ', m.min_value(i))\n    print('Max value in dimension', i, ': ', m.max_value(i))\n</code></pre> Output <pre><code>Map is not empty\n20 elements in the spatial map\n3 dimensions\nMin value in dimension 0: -2.57664\nMax value in dimension 0: 1.49101\nMin value in dimension 1: -1.52034\nMax value in dimension 1: 3.24052\nMin value in dimension 2: -2.92346\nMax value in dimension 2: 2.78224\n</code></pre>"},{"location":"spatial-containers/constructors/","title":"Constructors","text":"<p>The constructors defined by <code>pareto::spatial_map&lt;K,M,T,C,A&gt;::spatial_map</code> (or any other spatial container) instantiate new containers from a variety of data sources and optionally using a user supplied allocator <code>alloc</code> or comparison function object <code>comp</code>.</p> Method Container + AllocatorAwareContainer <code>explicit spatial_map(const allocator_type &amp;alloc = allocator_type())</code> <code>spatial_map(const spatial_map &amp;rhs)</code> <code>spatial_map(const spatial_map &amp;rhs, const allocator_type &amp;alloc)</code> <code>spatial_map(spatial_map &amp;&amp;rhs) noexcept</code> <code>spatial_map(spatial_map &amp;&amp;rhs, const allocator_type &amp;alloc) noexcept</code> AssociativeContainer + AllocatorAwareContainer <code>explicit spatial_map(const C &amp;comp, const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; spatial_map(InputIt first, InputIt last, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>spatial_map(std::initializer_list&lt;value_type&gt; il, const C &amp;comp = C(), const allocator_type &amp;alloc = allocator_type())</code> <code>template &lt;class InputIt&gt; spatial_map(InputIt first, InputIt last, const allocator_type &amp;alloc)</code> <code>spatial_map(std::initializer_list&lt;value_type&gt; il, const allocator_type &amp;alloc)</code> AssociativeContainer + AllocatorAwareContainer Assignment <code>spatial_map &amp;operator=(const spatial_map &amp;rhs)</code> <code>spatial_map &amp;operator=(spatial_map &amp;&amp;rhs) noexcept</code> AssociativeContainer Assignment <code>spatial_map &amp;operator=(std::initializer_list&lt;value_type&gt; il) noexcept</code> <p>Parameters</p> Parameter Description <code>alloc</code> allocator to use for all memory allocations of this container <code>comp</code> comparison function object to use for all comparisons of keys <code>first</code>, <code>last</code> the range to copy the elements from <code>rhs</code> another container to be used as source to initialize the elements of the container with <code>il</code> initializer list to initialize the elements of the container with <p>Requirements</p> Type requirements -<code>InputIt</code> must meet the requirements of LegacyInputIterator. -<code>Compare</code> must meet the requirements of Compare. -<code>Allocator</code> must meet the requirements of Allocator. <p>Complexity</p> Method Complexity Empty constructor \\(O(1)\\) Copy constructor \\(O(mn)\\) Move constructor \\(O(1)\\) if <code>get_allocator() == rhs.get_allocator()</code> Construct from range, or assignment \\(O(m n \\log n)\\) <p>Example</p> C++ <pre><code>#include &lt;pareto/spatial_map.h&gt;\n#include &lt;pareto/kd_tree.h&gt;\n// ...\n// Constructing the default spatial map\npareto::spatial_map&lt;double, 3, unsigned&gt; m;\n// Constructing a kd-tree spatial map\npareto::kd_tree&lt;double, 3, unsigned&gt; m;\n</code></pre> Python <pre><code>import pareto\n# ...\n# Constructing the default spatial map\nm = pareto.spatial_map() \n# // Constructing a kd-tree spatial map\nm = pareto.kd_tree() \n</code></pre>"},{"location":"spatial-containers/containers/","title":"Containers","text":"<p>Just like you can create a uni-dimensional map with:</p> C++ <pre><code>std::multimap&lt;double, unsigned&gt; m1;\n// or\nstd::unordered_map&lt;double, unsigned&gt; m2;\n</code></pre> Python <pre><code>m1 = sortedcontainers.SortedDict()\n# or\nm2 = dict()\n</code></pre> <p>Spatial containers allow you to create an \\(m\\)-dimensional map with something like:</p> C++ <pre><code>pareto::spatial_map&lt;double, 2, unsigned&gt; m1;\npareto::spatial_map&lt;double, 3, unsigned&gt; m2;\npareto::spatial_map&lt;double, 4, unsigned&gt; m3;\npareto::spatial_map&lt;double, 5, unsigned&gt; m4;\n</code></pre> Python <pre><code># The dimension will be set when you insert the first point\nm1 = pareto.spatial_map()\n</code></pre> <p>A <code>spatial_map</code> is currently defined as an alias to an <code>r_tree</code>. If you want to be specific about which data structure to use, you can directly define:</p> C++ <pre><code>pareto::r_tree&lt;double, 3, unsigned&gt; m1;\npareto::r_star_tree&lt;double, 3, unsigned&gt; m2;\npareto::kd_tree&lt;double, 3, unsigned&gt; m3;\npareto::quad_tree&lt;double, 3, unsigned&gt; m4;\npareto::implicit_tree&lt;double, 3, unsigned&gt; m5;\n</code></pre> Python <pre><code>m1 = pareto.r_tree()\nm2 = pareto.r_star_tree()\nm3 = pareto.kd_tree()\nm4 = pareto.quad_tree()\nm5 = pareto.implicit_tree()\n</code></pre> <p>Here's a summary of what each container is good at:</p> Container Best Application Optimal <code>kd_tree</code> Non-uniformly distributed objects Yes <code>r_tree</code> Non-uniformly distributed objects that might overlap in space Yes <code>r_star_tree</code> Same as <code>r_tree</code> with more expensive insertion and less expensive queries Yes <code>quad_tree</code> Uniformly distributed objects No <code>implicit_tree</code> Benchmarks only No <p>Although <code>pareto::front</code> and <code>pareto::archive</code> also implement the SpatialContainer concept, they serve a different purpose we discuss in Sections Front Concept and Archive Concept. However, their interface remains unchanged for the most common use cases:</p> C++ <pre><code>pareto::front&lt;double, 3, unsigned&gt; pf;\npareto::archive&lt;double, 3, unsigned&gt; ar;\n</code></pre> Python <pre><code>pf = pareto.front()\nar = pareto.archive()\n</code></pre> <p>Complexity</p> <ul> <li> <p>Containers with optimal asymptotic complexity have a \\(O(m \\log n)\\) cost to search, insert and remove elements.</p> </li> <li> <p>Quadtrees do not have optimal asymptotic complexity because removing elements might require reconstructing subtrees with cost \\(O(m n \\log n)\\). </p> </li> <li> <p>The container <code>implicit_tree</code> is emulates a tree with a <code>std::vector</code>. You can think of it as a multidimensional <code>flat_map</code>. However, unlike a flat map, sorting the elements in a single dimension does not make operations much unless \\(m \\leq 3\\). Its basic operations cost \\(O(mn)\\) and it's mostly used as a reference for our benchmarks.</p> </li> </ul>"},{"location":"spatial-containers/element-access/","title":"Element Access","text":"Method MapContainer Access and throw exception if it doesn't exist <code>mapped_type &amp;at(const key_type &amp;k);</code> <code>const mapped_type &amp;at(const key_type &amp;k) const;</code> Access and create new element if it doesn't exist <code>mapped_type &amp;operator[] (const key_type &amp;k);</code> <code>mapped_type &amp;operator[] (key_type &amp;&amp;k);</code> <code>template &lt;typename... Targs&gt; mapped_type &amp;operator()(const dimension_type &amp;x1, const Targs &amp;...xs);</code> <p>Parameters</p> <ul> <li><code>k</code> - the key of the element to find</li> <li><code>x1</code> - the value of the element to find in the first dimension</li> <li><code>xs</code> - the value of the element to find in other dimensions</li> </ul> <p>Return value</p> <p>A reference to the element associated with that key.</p> <p>Exceptions</p> <p><code>std::out_of_range</code> if the container does not have an element with the specified <code>key</code></p> <p>Complexity</p> \\[ O(m \\log n) \\] <p>Notes</p> <p>While the <code>at</code> function throws an error when the element is not found, <code>operator[]</code> creates a new element with that key if the element is not found. Like other libraries that handle multidimensional data, we use the <code>operator()</code> for element access as a convenience because the <code>operator[]</code> does not allow multiple parameters. We can still use <code>operator[]</code> with a <code>front::key_type</code> though. </p> <p>Note</p> <p>Like <code>std::map</code>, and unlike <code>std::multimap</code>, spatial containers implement the element access operators even though duplicate keys are permitted. The reason <code>std::multimap</code> does not implement these operators is because the operator might be ambiguous when there is more than one element that matches the given key. </p> <p>By convention we formally remove this ambiguity by always using the first element that matches that key. It's up to the library user to decide if this behaviour is appropriate for their application. If not, the modifier functions should be used instead.</p> <p>Example</p> C++ <pre><code>spatial_map&lt;double, 3, unsigned&gt; m;\n// Set some values\nm(-2.57664, -1.52034, 0.600798) = 17;\nm(-2.14255, -0.518684, -2.92346) = 32;\nm(-1.63295, 0.912108, -2.12953) = 36;\nm(-0.653036, 0.927688, -0.813932) = 13;\nm(-0.508188, 0.871096, -2.25287) = 32;\nm(-2.55905, -0.271349, 0.898137) = 6;\nm(-2.31613, -0.219302, 0) = 8;\nm(-0.639149, 1.89515, 0.858653) = 10;\nm(-0.401531, 2.30172, 0.58125) = 39;\nm(0.0728106, 1.91877, 0.399664) = 25;\nm(-1.09756, 1.33135, 0.569513) = 20;\nm(-0.894115, 1.01387, 0.462008) = 11;\nm(-1.45049, 1.35763, 0.606019) = 17;\nm(0.152711, 1.99514, -0.112665) = 13;\nm(-2.3912, 0.395611, 2.78224) = 11;\nm(-0.00292544, 1.29632, -0.578346) = 20;\nm(0.157424, 2.30954, -1.23614) = 6;\nm(0.453686, 1.02632, -2.24833) = 30;\nm(0.693712, 1.12267, -1.37375) = 12;\nm(1.49101, 3.24052, 0.724771) = 24;\n// Access value\nstd::cout &lt;&lt; \"Element access: \" &lt;&lt; m(1.49101, 3.24052, 0.724771) &lt;&lt; std::endl;\n</code></pre> Python <pre><code>m = pareto.spatial_map()\n# Set some values\nm[-2.57664, -1.52034, 0.600798] = 17\nm[-2.14255, -0.518684, -2.92346] = 32\nm[-1.63295, 0.912108, -2.12953] = 36\nm[-0.653036, 0.927688, -0.813932] = 13\nm[-0.508188, 0.871096, -2.25287] = 32\nm[-2.55905, -0.271349, 0.898137] = 6\nm[-2.31613, -0.219302, 0] = 8\nm[-0.639149, 1.89515, 0.858653] = 10\nm[-0.401531, 2.30172, 0.58125] = 39\nm[0.0728106, 1.91877, 0.399664] = 25\nm[-1.09756, 1.33135, 0.569513] = 20\nm[-0.894115, 1.01387, 0.462008] = 11\nm[-1.45049, 1.35763, 0.606019] = 17\nm[0.152711, 1.99514, -0.112665] = 13\nm[-2.3912, 0.395611, 2.78224] = 11\nm[-0.00292544, 1.29632, -0.578346] = 20\nm[0.157424, 2.30954, -1.23614] = 6\nm[0.453686, 1.02632, -2.24833] = 30\nm[0.693712, 1.12267, -1.37375] = 12\nm[1.49101, 3.24052, 0.724771] = 24\n# Access value\nprint('Element access:', m[1.49101, 3.24052, 0.724771])\n</code></pre> Output <pre><code>Element access: 24\n</code></pre>"},{"location":"spatial-containers/iterators/","title":"Iterators","text":"Method MultimapContainer Get constant iterators <code>const_iterator begin() const noexcept;</code> <code>const_iterator end() const noexcept;</code> <code>const_iterator cbegin() const noexcept;</code> <code>const_iterator cend() const noexcept;</code> Get iterators <code>iterator begin() noexcept;</code> <code>iterator end() noexcept;</code> Get reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; rbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; rend() const noexcept;</code> <code>std::reverse_iterator&lt;iterator&gt; rbegin() noexcept</code>; <code>std::reverse_iterator&lt;iterator&gt; rend() noexcept;</code> Get constant reverse iterators <code>std::reverse_iterator&lt;const_iterator&gt; crbegin() const noexcept;</code> <code>std::reverse_iterator&lt;const_iterator&gt; crend() const noexcept;</code> <p>Return value</p> <ul> <li><code>begin()</code> - Iterator to the first element in the container</li> <li><code>end()</code> - Iterator to the past-the-end element in the container (see notes)</li> </ul> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>At each iteration, these iterators report the next tree element in a depth-first search algorithm. The reverse iterators perform a reversed depth-first search algorithm, where we get the next element at the rightmost element of the left sibling node or return the parent node when there are no more siblings.</p> <p>Info</p> <p>All spatial maps have two kinds of iterators: the usual iterators and query iterators. Query iterators contain a list of predicates and skip all elements that do not match these predicates. The functions in this section describe only the usual iterators. </p> <p>Query iterators and normal iterators compare equal when they point to the same element, but this doesn't mean their next element is the same element.</p> <p>Python Iterators</p> <p>The Python interface uses ranges instead of single iterators. The <code>begin</code> and <code>end</code> functions are not directly exposed.</p> <p>Note for C++ Beginners</p> <p>The iterators <code>begin()</code> point to the first element in the container. The iterators <code>end()</code> point to one position after the last element in the container.</p> <p></p> <p>This means that, given an iterator <code>it</code> initially equivalent to <code>begin()</code>, we can iterate elements <code>while (it != end()) { ++it; }</code>. If the <code>spatial_map</code> is empty, <code>begin()</code> returns an iterator equal to <code>end()</code>.</p> <p>The functions beginning with <code>c</code> return constant iterators. When we dereference a constant iterators with <code>operator*</code>, they only return references to constant values (<code>const value_type&amp;</code>).</p> <p>The functions beginning with <code>r</code> return reverse iterators. Reverse iterators go from the last to the first element.</p> <p>Example of reverse iterators</p> <p></p> <p>The functions beginning with <code>cr</code> return constant reverse iterators.    </p> <p>!!! note \"Intermediate C++**     Like all other associative containers, non-const iterators return references to <code>std::pair&lt;const key_type, mapped_type&gt;</code> and not  <code>std::pair&lt;key_type, mapped_type&gt;</code> like one might think. This is meant to protect the associative relationship between nodes in the container. </p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>std::cout &lt;&lt; \"Iterators:\" &lt;&lt; std::endl;\nfor (const auto&amp; [point, value]: m) {\n    std::cout &lt;&lt; point &lt;&lt; \" -&gt; \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\nstd::cout &lt;&lt; \"Reversed Iterators:\" &lt;&lt; std::endl;\nfor (auto it = m.rbegin(); it != m.rend(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre> Python <pre><code>print('Iterators')\nfor [point, value] in m:\n    print(point, '-&gt;', value)\n\nprint('Reversed Iterators')\nfor [point, value] in reversed(m):\n    print(point, '-&gt;', value)\n</code></pre> Output <pre><code>Iterators:\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.31613, -0.219302, 0] -&gt; 8\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[1.49101, 3.24052, 0.724771] -&gt; 24\nReversed Iterators:\n[1.49101, 3.24052, 0.724771] -&gt; 24\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.894115, 1.01387, 0.462008] -&gt; 11\n[-2.31613, -0.219302, 0] -&gt; 8\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[0.693712, 1.12267, -1.37375] -&gt; 12\n[0.453686, 1.02632, -2.24833] -&gt; 30\n[-0.508188, 0.871096, -2.25287] -&gt; 32\n[-0.653036, 0.927688, -0.813932] -&gt; 13\n[-1.63295, 0.912108, -2.12953] -&gt; 36\n[-2.14255, -0.518684, -2.92346] -&gt; 32\n</code></pre>"},{"location":"spatial-containers/lookup-and-queries/","title":"Lookup and Queries","text":"Method Multimap Returns the number of elements matching specific key <code>size_type count(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; size_type count(const L &amp;p) const</code> Finds element with specific key <code>iterator find(const key_type &amp;p);</code> <code>const_iterator find(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; iterator find(const L &amp;p)</code> <code>template &lt;class L&gt; const_iterator find(const L &amp;p) const;</code> Checks if the container contains element with specific key <code>bool contains(const key_type &amp;p) const;</code> <code>template &lt;class L&gt; bool contains(const L &amp;p) const;</code> SpatialContainer Get iterator to first element that passes the predicates <code>const_iterator find(const predicate_list_type &amp;ps) const noexcept;</code> <code>iterator find(const predicate_list_type &amp;ps) noexcept;</code> Find intersection between point and container <code>iterator find_intersection(const key_type &amp;p);</code> <code>const_iterator find_intersection(const key_type &amp;p) const;</code> Find intersection between container and query box <code>iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_intersection(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find points inside a query box (excluding borders) <code>iterator find_within(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_within(const key_type &amp;lb, const key_type &amp;ub) const</code> Find points outside a query box <code>iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub);</code> <code>const_iterator find_disjoint(const key_type &amp;lb, const key_type &amp;ub) const;</code> Find the elements closest to a point <code>iterator find_nearest(const key_type &amp;p);</code> <code>const_iterator find_nearest(const key_type &amp;p) const;</code> <code>iterator find_nearest(const key_type &amp;p, size_t k);</code> <code>const_iterator find_nearest(const key_type &amp;p, size_t k) const;</code> <code>iterator find_nearest(const box_type &amp;b, size_t k);</code> <code>const_iterator find_nearest(const box_type &amp;b, size_t k) const;</code> Find min/max elements <code>iterator max_element(size_t dimension)</code> <code>const_iterator max_element(size_t dimension) const</code> <code>iterator min_element(size_t dimension)</code> <code>const_iterator min_element(size_t dimension) const</code> <p>Parameters</p> <ul> <li><code>ps</code> - a list of predicates</li> <li><code>p</code> - a point of type <code>key_value</code> or convertible to <code>key_value</code></li> <li><code>lb</code> and <code>ub</code> - lower and upper bounds of the query box</li> <li><code>k</code> - number of nearest elements</li> </ul> <p>Return value</p> <ul> <li><code>count()</code>: <code>size_type</code>: number of elements with a given key</li> <li><code>container()</code>: <code>bool</code>: <code>true</code> if and only if the container contains an element with the given key <code>p</code></li> <li><code>find_*</code>: <code>iterator</code> and <code>const_iterator</code> - Iterator to the first element that passes the query predicates</li> <li><code>find</code> returns a normal iterator</li> <li>all other <code>find_*</code> functions return a query iterator (see below)</li> <li><code>size_type</code> - Number of elements erased</li> </ul> <p>Complexity</p> \\[ O(m \\log n) \\] <p>Notes</p> <p>Query iterators might store a list of predicates that limit iterators to query results. A query iterator skips all elements that do not match its predicates.</p> <p>There are five types of predicates:</p> Predicate type Description <code>intersects</code> return only elements that intersect a given query box. <code>within</code> return only elements within a given query box. This is the same as <code>intersects</code> but it excludes the borders. <code>disjoint</code> return only elements that do not intersect a given query box. <code>nearest</code> return only the \\(k\\) nearest elements to a reference point or query box. <code>satisfies</code> return only elements that pass a predicate provided by the user. <p>Predicate lists</p> <p>Query iterators contain an element of type <code>pareto::predicate_list</code>.  When a <code>predicate_list</code> is being constructed, it will: 1) compress to predicates to eliminate any redundancy in the search requirements, and  2) sort the predicates by how restrictive they are so that the search for the next element is as efficient as possible.</p> <p>Comparing Iterators</p> <p>Although a normal iterator and a query iterator that point to the same element compare equal, this does not mean their <code>operator++</code> will return the same element. The past-the-end element of all query iterators is also the <code>end()</code> iterator.</p> <p>Lower and Upper bounds</p> <p>Because of how spatial container work, we do not guarantee equivalent elements are necessarily stored in sequence. Thus, unlike <code>std::multimap</code> there are no <code>equal_range</code>, <code>lower_bound</code> and <code>upper_bound</code> functions. The same behaviour must be achieved with the <code>find_intersection</code> function.</p> <p>Examples</p> <p>Continuing from the previous example:</p> C++ <pre><code>for (auto it = m.find_intersection({-10,-10,-10}, {-2.3912, 0.395611, 2.78224}); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = m.find_within({-10,-10,-10}, {-2.3912, 0.395611, 2.78224}); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = m.find_disjoint({-10,-10,-10}, {+0.71, +1.19, +0.98}); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nfor (auto it = m.find_nearest({-2.3912, 0.395611, 2.78224}, 2); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\nauto it = m.find_nearest({2.5, 2.5, 2.5});\nstd::cout &lt;&lt; it-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n</code></pre> Python <pre><code>for [point, value] in m.find_intersection(pareto.point([-10, -10, -10]), pareto.point([-1.21188, -1.24192, +10])):\n    print(point, '-&gt;', value)\n\nfor [point, value] in m.find_within(pareto.point([-10, -10, -10]), pareto.point([-1.21188, -1.24192, +10])):\n    print(point, '-&gt;', value)\n\nfor [point, value] in m.find_disjoint(pareto.point([+0.2, +0.19, -1]), pareto.point([+0.71, +1.19, +10])):\n    print(point, '-&gt;', value)\n\nfor [point, value] in m.find_nearest(pareto.point([-1.21188, -1.24192, 10]), 2):\n    print(point, '-&gt;', value)\n\nfor [point, value] in m.find_nearest(pareto.point([2.5, 2.5, 10])):\n    print(point, '-&gt;', value)\n</code></pre> Output <pre><code>[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.57664, -1.52034, 0.600798] -&gt; 17\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-0.639149, 1.89515, 0.858653] -&gt; 10\n[-0.401531, 2.30172, 0.58125] -&gt; 39\n[-1.09756, 1.33135, 0.569513] -&gt; 20\n[-1.45049, 1.35763, 0.606019] -&gt; 17\n[-0.00292544, 1.29632, -0.578346] -&gt; 20\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n[0.152711, 1.99514, -0.112665] -&gt; 13\n[0.157424, 2.30954, -1.23614] -&gt; 6\n[-2.3912, 0.395611, 2.78224] -&gt; 11\n[-2.55905, -0.271349, 0.898137] -&gt; 6\n[0.0728106, 1.91877, 0.399664] -&gt; 25\n</code></pre>"},{"location":"spatial-containers/modifiers/","title":"Modifiers","text":"Method Container + AllocatorAwareContainer Exchanges the contents of the container with those of <code>rhs</code> <code>void swap(kd_tree &amp;rhs) noexcept;</code> Multimap Erases all elements from the container <code>void clear();</code> Inserts element(s) into the container <code>iterator insert(const value_type &amp;v);</code> <code>iterator insert(value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(P &amp;&amp;v);</code> <code>iterator insert(iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, const value_type &amp;v);</code> <code>iterator insert(const_iterator, value_type &amp;&amp;v);</code> <code>template &lt;class P&gt; iterator insert(const_iterator hint, P &amp;&amp;v);</code> <code>template &lt;class Inputiterator&gt; void insert(Inputiterator first, Inputiterator last);</code> <code>void insert(std::initializer_list&lt;value_type&gt; init);</code> Inserts a new element into the container constructed in-place with the given <code>args</code> <code>template &lt;class... Args&gt; iterator emplace(Args &amp;&amp;...args);</code> <code>template &lt;class... Args&gt; iterator emplace_hint(const_iterator, Args &amp;&amp;...args);</code> Removes specified elements from the container <code>iterator erase(const_iterator position);</code> <code>iterator erase(iterator position);</code> <code>iterator erase(const_iterator first, const_iterator last);</code> <code>size_type erase(const key_type &amp;k);</code> Attempts to extract (\"splice\") each element in <code>source</code> and insert it into <code>*this</code> <code>void merge(spatial_map &amp;source) noexcept;</code> <code>void merge(spatial_map &amp;&amp;source) noexcept;</code> <p>Parameters</p> <ul> <li><code>rhs</code> - container to exchange the contents with</li> <li><code>v</code> - element value to insert</li> <li><code>first</code>, <code>last</code> - range of elements to insert/erase</li> <li><code>init</code> - initializer list to insert the values from</li> <li><code>hint</code> - iterator, used as a suggestion as to where to start the search</li> <li><code>position</code> - iterator pointer to element to erase</li> <li><code>k</code> - key value of the elements to remove</li> <li><code>source</code> - container to get elements from</li> </ul> <p>Return value</p> <ul> <li><code>iterator</code> - Iterator to the new element (<code>insert</code>) or following the last removed element (<code>erase</code>)</li> <li><code>size_type</code> - Number of elements erased</li> </ul> <p>Complexity</p> <ul> <li><code>insert</code>, <code>emplace</code>,  <code>erase</code>: \\(O(m \\log n)\\)</li> <li><code>swap</code>: \\(O(1)\\)</li> <li><code>merge</code>: \\(O(mn)\\)</li> </ul> <p>Notes</p> <p>The containers cannot take advantage of the hints yet.</p> <p>Example</p> <p>Continuing from the previous example:</p> C++ <pre><code>m.insert({ {1.49101, 3.24052, 0.724771}, 24});\nm.erase({1.49101, 3.24052, 0.724771});\n</code></pre> Python <pre><code>m.insert([pareto.point([1.49101, 3.24052, 0.724771]), 24])\ndel m[1.49101, 3.24052, 0.724771]\n</code></pre>"},{"location":"spatial-containers/observers/","title":"Observers","text":"Method Multimap Returns the function that compares keys <code>key_compare key_comp() const noexcept;</code> Returns the function that compares keys in objects of type value_type <code>value_compare value_comp() const noexcept</code> SpatialMap Returns the function that compares keys in a single dimension <code>dimension_compare dimension_comp() const noexcept;</code> <p>Return value</p> <p>A callable function that compares dimensions, keys, or values.</p> <p>Complexity</p> \\[ O(1) \\] <p>Notes</p> <p>These functions return copies of the container's constructor argument <code>comp</code>, or a wrappers around these copies.</p> <p>Observers</p> <p>These observers are useful in template functions that might receive spatial containers unknown to the function.    </p> <p>Most applications don't really need these observers. If you created the container, you already know the container compares its keys.  </p> C++ <pre><code>auto fn = m.dimension_comp();\nif (fn(2.,3.)) {\n    std::cout &lt;&lt; \"2 is less than 3\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"2 is not less than 3\" &lt;&lt; std::endl;\n}\n</code></pre> Output <pre><code>2 is less than 3\n</code></pre>"},{"location":"spatial-containers/relational-operators/","title":"Relational Operators","text":"<p>These are non-member functions.</p> Method Multimap Compares the values in the multimap <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator==(const spatial_map&lt;K, M, T, C, A&gt; &amp;lhs, const spatial_map&lt;K, M, T, C, A&gt; &amp;rhs);</code> <code>template &lt;class K, size_t M, class T, class C, class A&gt; bool operator!=(const spatial_map&lt;K, M, T, C, A&gt; &amp;lhs, const spatial_map&lt;K, M, T, C, A&gt; &amp;rhs);</code> <p>Parameters</p> <ul> <li><code>lhs</code>, <code>rhs</code> - <code>spatial_map</code>s whose contents to compare</li> </ul> <p>Return value</p> <p><code>true</code> if the internal contents of the <code>spatial_map</code>s are equal, false otherwise. </p> <p>Complexity</p> \\[ O(n) \\] <p>Notes</p> <p>Warning</p> <p>This operator tells us if the internal trees are equal and not if they contain the same elements. This is because the standard defines that this operation should take \\(O(n)\\) time. Two trees might contain the same elements in different subtrees if their insertion order was different. </p> <p>If you need to compare if the elements of <code>lhs</code> and <code>rhs</code> are the same, regardless of their internal representation, you have to iterate <code>lhs</code> and iteratively call <code>find</code> on the second container. This operation takes \\(O(m n \\log n)\\) time.</p> <p>We do not include <code>operator&lt;</code>,  <code>operator&gt;</code>,  <code>operator&lt;=</code>,  <code>operator&gt;=</code> for spatial containers because std::lexicographical_compare would be semantically meaningless in a multidimensional context where we need to return a value in \\(O(n)\\) time and, by definition, there is no priority between key dimensions. </p> <p>Example</p> C++ <pre><code>spatial_map&lt;double, 3, unsigned&gt; m2(m);\nif (m == m2) {\n    std::cout &lt;&lt; \"The containers have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (m.size() != m2.size()) {\n        std::cout &lt;&lt; \"The containers do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The containers might not have the same elements\" &lt;&lt; std::endl;\n        // You need a for loop after here to make sure\n    }\n}\n\nspatial_map&lt;double, 3, unsigned&gt; m3(m.begin(), m.end());\nif (m == m3) {\n    std::cout &lt;&lt; \"The containers have the same elements\" &lt;&lt; std::endl;\n} else {\n    if (m.size() != m3.size()) {\n        std::cout &lt;&lt; \"The containers do not have the same elements\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"The containers might not have the same elements\" &lt;&lt; std::endl;\n        // You need a for loop after here to make sure\n    }\n}\n</code></pre> Python <pre><code>m2 = pareto.spatial_map(m)\nif m == m2:\n    print('The containers have the same elements')\nelse:\n    if len(m) != len(m2):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n\nm3 = pareto.spatial_map()\nfor [k, v] in m:\n    m3[k] = v\n\nif m == m3:\n    print('The containers have the same elements')\nelse:\n    if len(m) != len(m3):\n        print('The containers do not have the same elements')\n    else:\n        print('The containers might not have the same elements')\n        # You need a for loop after here to make sure\n</code></pre> Output <pre><code>The containers have the same elements\nThe containers might not have the same elements\n</code></pre>"},{"location":"spatial-containers/types/","title":"Types","text":"<p>This table summarizes the public types in all SpatialContainers:</p> Name Type Notes Container <code>value_type</code> <code>std::pair&lt;const pareto::point&lt;K,M&gt;,T&gt;</code> The pair key is <code>const</code>, like in other associative containers <code>reference</code> <code>value_type&amp;</code> <code>const_reference</code> <code>value_type const &amp;</code> <code>iterator</code> Iterator pointing to a <code>value_type</code> A LegacyBidirectionalIterator convertible to <code>const_iterator</code> <code>const_iterator</code> Iterator pointing to a <code>const value_type</code> Implements LegacyBidirectionalIterator concept <code>difference_type</code> A signed integer <code>size_type</code> An unsigned integer ReversibleContainer <code>reverse_iterator</code> <code>std::reverse_iterator&lt;iterator&gt;</code> <code>const_reverse_iterator</code> <code>std::reverse_iterator&lt;const_iterator&gt;</code> AssociativeContainer <code>key_type</code> <code>pareto::point&lt;K,M&gt;</code> <code>key_type</code> is not const, so you can use it to construct and manipulate new points <code>mapped_type</code> <code>T</code> <code>key_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>key_compare</code> defines a lexicographic ordering relation over keys using <code>dimension_compare</code> <code>value_compare</code> <code>std::function&lt;bool(const value_type &amp;, const value_type &amp;)&gt;</code> <code>value_compare</code> defines an ordering relation over <code>value_type</code> using <code>key_compare</code> AllocatorAwareContainer <code>allocator_type</code> <code>A</code>, or <code>pareto::default_allocator&lt;value_type&gt;</code> by default <code>allocator_type::value_type</code> is the same as <code>value_type</code> SpatialContainer <code>dimension_type</code> <code>K</code> <code>dimension_compare</code> <code>C</code>, or <code>std::less&lt;K&gt;</code> by default <code>dimension_compare</code> defines an ordering relation over each <code>key_value</code> dimension using <code>C</code> <code>box_type</code> <code>pareto::query_box&lt;dimension_type, M&gt;</code> <code>predicate_list_type</code> <code>pareto::predicate_list&lt;dimension_type, M, T&gt;</code> <p>Notes</p> <p><code>dimension_type</code> refers to a single dimension in <code>key_type</code>. Although this is usually a number, it might be an object of any other type.</p> <p>Key type</p> <p>While the container is defined with the uni-dimensional key <code>K</code>, the container expands that into an <code>M</code>-dimensional point of type <code>pareto::point&lt;K,M&gt;</code>.  This does not break any named requirement for containers, as types can be different from their template parameters.</p> <p>Iterators to constant keys</p> <p>The first type in <code>value_type</code> (<code>const pareto::point&lt;K,M&gt;</code>) is <code>const</code>. This is a requirement of associative containers. Otherwise, the user could externally change keys through references and the container nodes would no longer be properly ordered.</p> <p>Bidirectional Iterators</p> <p>A <code>spatial_map&lt;K,M,T,A&gt;::iterator</code> is a LegacyBidirectionalIterator convertible to a <code>const_iterator</code> (but to the other way around). This means iterators can move forward and backward. However, we can also use queries to explore specific regions of space, so it's still reasonably easy to look for random points and things like that.</p>"}]}